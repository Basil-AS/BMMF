<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Fair Meeting Point Finder v3.0</title>
  <meta name="description" content="–ü–æ–∏—Å–∫ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏ –≤—Å—Ç—Ä–µ—á–∏ —Å —Ä–∞–≤–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –≤ –ø—É—Ç–∏">
  <style>
    :root {
      --bg: #0a0c0f;
      --panel: #11141a;
      --panel2: #0d1015;
      --panel3: #181d26;
      --text: #e8ecf2;
      --muted: #8a95a5;
      --line: #252d3a;
      --accent: #4d9fff;
      --accent2: #38bdf8;
      --ok: #34d399;
      --warn: #fbbf24;
      --bad: #f87171;
      --accent-soft: rgba(77, 159, 255, 0.12);
      --accent-border: rgba(77, 159, 255, 0.3);
      --ok-soft: rgba(52, 211, 153, 0.1);
      --ok-border: rgba(52, 211, 153, 0.3);
      --warn-soft: rgba(251, 191, 36, 0.1);
      --warn-border: rgba(251, 191, 36, 0.3);
      --bad-soft: rgba(248, 113, 113, 0.1);
      --bad-border: rgba(248, 113, 113, 0.3);
      --sidebar-width: 440px;
    }

    [data-theme="light"] {
      --bg: #f5f7fa;
      --panel: #ffffff;
      --panel2: #f0f2f5;
      --panel3: #e5e8ec;
      --text: #1a1d24;
      --muted: #5a6578;
      --line: #d0d5dd;
      --accent: #2563eb;
      --accent2: #0891b2;
      --ok: #059669;
      --warn: #d97706;
      --bad: #dc2626;
      --accent-soft: rgba(37, 99, 235, 0.08);
      --accent-border: rgba(37, 99, 235, 0.25);
      --ok-soft: rgba(5, 150, 105, 0.08);
      --ok-border: rgba(5, 150, 105, 0.25);
      --warn-soft: rgba(217, 119, 6, 0.08);
      --warn-border: rgba(217, 119, 6, 0.25);
      --bad-soft: rgba(220, 38, 38, 0.08);
      --bad-border: rgba(220, 38, 38, 0.25);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      overflow: hidden;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--panel2);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--line);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .main {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      gap: 12px;
      flex-wrap: wrap;
      flex-shrink: 0;
    }

    header h1 {
      font-size: 14px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    header h1 span {
      color: var(--accent);
    }

    header .subtitle {
      font-size: 10px;
      color: var(--muted);
    }

    .header-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .sidebar {
      width: var(--sidebar-width);
      min-width: 340px;
      max-width: 55vw;
      display: flex;
      flex-direction: column;
      background: var(--bg);
      border-right: 1px solid var(--line);
      overflow: hidden;
      resize: horizontal;
    }

    .sidebar-scroll {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 8px;
      overflow: hidden;
      flex-shrink: 0;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      background: var(--panel2);
      cursor: pointer;
      user-select: none;
      border-bottom: 1px solid var(--line);
    }

    .card-header h2 {
      font-size: 11px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .card-header .badge {
      font-size: 9px;
      padding: 1px 5px;
      border-radius: 8px;
      background: var(--accent-soft);
      color: var(--accent);
      border: 1px solid var(--accent-border);
    }

    .card-header .toggle {
      font-size: 9px;
      color: var(--muted);
      transition: transform 0.2s;
    }

    .card.collapsed .card-header .toggle {
      transform: rotate(-90deg);
    }

    .card.collapsed .card-body {
      display: none;
    }

    .card-body {
      padding: 10px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
    }

    .row3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 6px;
      margin-bottom: 6px;
    }

    .row4 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr auto;
      gap: 6px;
      margin-bottom: 6px;
    }

    .full {
      margin-bottom: 6px;
    }

    label {
      font-size: 9px;
      color: var(--muted);
      margin-bottom: 3px;
      font-weight: 500;
    }

    .field-label {
      display: flex;
      align-items: center;
      gap: 4px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    input,
    select,
    textarea,
    button {
      width: 100%;
      padding: 6px 8px;
      font-size: 11px;
      border: 1px solid var(--line);
      border-radius: 5px;
      background: var(--panel2);
      color: var(--text);
      outline: none;
      transition: all 0.15s;
    }

    input[type="checkbox"],
    input[type="radio"] {
      width: auto;
      padding: 0;
      border: none;
      background: transparent;
    }

    input:focus,
    select:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
    }

    input::placeholder,
    textarea::placeholder {
      color: var(--muted);
      opacity: 0.6;
    }

    button {
      cursor: pointer;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    button:hover:not(:disabled) {
      border-color: var(--accent);
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .btn-accent {
      background: var(--accent-soft);
      border-color: var(--accent-border);
      color: var(--accent);
    }

    .btn-accent:hover:not(:disabled) {
      background: var(--accent);
      color: #fff;
    }

    .btn-ok {
      background: var(--ok-soft);
      border-color: var(--ok-border);
      color: var(--ok);
    }

    .btn-warn {
      background: var(--warn-soft);
      border-color: var(--warn-border);
      color: var(--warn);
    }

    .btn-bad {
      background: var(--bad-soft);
      border-color: var(--bad-border);
      color: var(--bad);
    }

    .btn-ghost {
      background: transparent;
    }

    .btn-sm {
      padding: 4px 6px;
      font-size: 10px;
    }

    .btn-lg {
      padding: 10px;
      font-size: 12px;
    }

    .help-btn {
      width: 14px;
      height: 14px;
      padding: 0;
      font-size: 9px;
      border-radius: 50%;
      background: var(--accent-soft);
      border: 1px solid var(--accent-border);
      color: var(--accent);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .help-btn:hover {
      background: var(--accent);
      color: #fff;
    }

    .copy-btn {
      width: auto;
      padding: 2px 6px;
      font-size: 9px;
      margin-left: 4px;
    }

    .status {
      padding: 6px 8px;
      border-radius: 5px;
      font-size: 10px;
      line-height: 1.3;
      border: 1px solid var(--line);
      background: var(--panel2);
      margin-top: 6px;
    }

    .status.ok {
      background: var(--ok-soft);
      border-color: var(--ok-border);
    }

    .status.warn {
      background: var(--warn-soft);
      border-color: var(--warn-border);
    }

    .status.bad {
      background: var(--bad-soft);
      border-color: var(--bad-border);
    }

    .status.info {
      background: var(--accent-soft);
      border-color: var(--accent-border);
    }

    .points-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .point-item {
      display: grid;
      grid-template-columns: auto auto 1fr auto;
      gap: 6px;
      align-items: center;
      padding: 6px 8px;
      background: var(--panel2);
      border-radius: 6px;
      margin-bottom: 4px;
      border: 1px solid transparent;
      transition: all 0.15s;
    }

    .point-item:hover {
      border-color: var(--accent-border);
    }

    .point-item:last-child {
      margin-bottom: 0;
    }

    .point-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .point-info {
      min-width: 0;
    }

    .point-name {
      font-size: 10px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .point-name input {
      padding: 2px 4px;
      font-size: 10px;
      font-weight: 600;
      width: 90px;
    }

    .point-coords {
      font-size: 8px;
      color: var(--muted);
      font-family: monospace;
    }

    .point-transport {
      font-size: 8px;
      padding: 1px 4px;
      border-radius: 3px;
      background: var(--panel3);
    }

    .point-transport.auto {
      background: rgba(251, 191, 36, 0.15);
      color: var(--warn);
    }

    .point-actions {
      display: flex;
      gap: 2px;
    }

    .point-actions button {
      padding: 2px 4px;
      font-size: 9px;
    }

    .empty-state {
      text-align: center;
      padding: 12px;
      color: var(--muted);
      font-size: 10px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 6px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 3px 6px;
      font-size: 9px;
      border-radius: 10px;
      background: var(--panel2);
      border: 1px solid var(--line);
    }

    .chip .val {
      font-weight: 700;
      font-family: monospace;
    }

    .chip.ok {
      background: var(--ok-soft);
      border-color: var(--ok-border);
    }

    .chip.warn {
      background: var(--warn-soft);
      border-color: var(--warn-border);
    }

    .chip.bad {
      background: var(--bad-soft);
      border-color: var(--bad-border);
    }

    .progress-container {
      margin-top: 6px;
    }

    .progress-bar {
      height: 3px;
      background: var(--line);
      border-radius: 2px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      transition: width 0.3s;
    }

    .progress-text {
      font-size: 9px;
      color: var(--muted);
      margin-top: 3px;
      display: flex;
      justify-content: space-between;
    }

    .live-stats {
      display: flex;
      gap: 8px;
      margin-top: 6px;
      font-size: 9px;
      flex-wrap: wrap;
    }

    .live-stat {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .live-stat .icon {
      font-size: 10px;
    }

    .live-stat .num {
      font-weight: 700;
      font-family: monospace;
    }

    .live-stat.ok .num {
      color: var(--ok);
    }

    .live-stat.bad .num {
      color: var(--bad);
    }

    .result-summary {
      background: var(--ok-soft);
      border: 1px solid var(--ok-border);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 8px;
    }

    .result-summary h3 {
      font-size: 12px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .result-metrics {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
    }

    .metric-box {
      background: var(--panel);
      padding: 4px;
      border-radius: 4px;
      text-align: center;
    }

    .metric-box .val {
      font-size: 13px;
      font-weight: 700;
      color: var(--accent);
      font-family: monospace;
    }

    .metric-box .label {
      font-size: 7px;
      color: var(--muted);
      text-transform: uppercase;
    }

    .coords-row {
      display: flex;
      align-items: center;
      gap: 4px;
      font-family: monospace;
      font-size: 9px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .coords-row code {
      flex: 1;
    }

    .route-times {
      margin-top: 8px;
      font-size: 10px;
    }

    .route-time-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 0;
      border-bottom: 1px solid var(--line);
    }

    .route-time-item:last-child {
      border-bottom: none;
    }

    .route-time-item .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .route-time-item .name {
      flex: 1;
    }

    .route-time-item .time {
      font-weight: 700;
      font-family: monospace;
      color: var(--accent);
    }

    .route-time-item .walk-extra {
      font-size: 8px;
      color: var(--warn);
      margin-left: 4px;
    }

    .top-results {
      margin-top: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .top-result-item {
      display: grid;
      grid-template-columns: 20px 1fr auto;
      gap: 6px;
      align-items: center;
      padding: 6px;
      background: var(--panel2);
      border-radius: 5px;
      margin-bottom: 4px;
      border: 1px solid var(--line);
      cursor: pointer;
      transition: all 0.15s;
    }

    .top-result-item:hover {
      border-color: var(--accent-border);
    }

    .top-result-item.active {
      border-color: var(--ok);
      background: var(--ok-soft);
    }

    .top-result-item .rank {
      font-size: 11px;
      font-weight: 700;
      color: var(--muted);
      text-align: center;
    }

    .top-result-item .rank.gold {
      color: #fbbf24;
    }

    .top-result-item .rank.silver {
      color: #94a3b8;
    }

    .top-result-item .rank.bronze {
      color: #d97706;
    }

    .top-result-item .info {
      font-size: 10px;
    }

    .top-result-item .times {
      font-size: 9px;
      color: var(--muted);
      font-family: monospace;
    }

    .top-result-item .metric-tag {
      font-size: 8px;
      padding: 1px 4px;
      border-radius: 3px;
      background: var(--accent-soft);
      color: var(--accent);
      margin-left: 4px;
    }

    .top-result-item .walk-tag {
      font-size: 8px;
      padding: 1px 4px;
      border-radius: 3px;
      background: var(--ok-soft);
      color: var(--ok);
      margin-left: 2px;
    }

    .top-result-item .score {
      font-size: 11px;
      font-weight: 700;
      font-family: monospace;
    }

    .load-more-btn {
      margin-top: 4px;
      padding: 6px;
      font-size: 10px;
    }

    .routes-panel {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 8px;
    }

    .route-card {
      background: var(--panel2);
      border-radius: 5px;
      padding: 6px;
      margin-bottom: 4px;
      border: 1px solid var(--line);
    }

    .route-card:last-child {
      margin-bottom: 0;
    }

    .route-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 3px;
    }

    .route-header .name {
      font-size: 10px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .route-header .time {
      font-size: 11px;
      font-weight: 700;
      color: var(--accent);
      font-family: monospace;
    }

    .route-segments {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }

    .segment {
      display: inline-flex;
      align-items: center;
      gap: 2px;
      padding: 2px 4px;
      font-size: 8px;
      border-radius: 3px;
      background: var(--panel3);
      border: 1px solid var(--line);
    }

    .segment.walk {
      background: rgba(148, 163, 184, 0.15);
    }

    .segment.bus {
      background: rgba(34, 197, 94, 0.15);
      border-color: rgba(34, 197, 94, 0.3);
    }

    .segment.trolleybus {
      background: rgba(59, 130, 246, 0.15);
      border-color: rgba(59, 130, 246, 0.3);
    }

    .segment.tram {
      background: rgba(239, 68, 68, 0.15);
      border-color: rgba(239, 68, 68, 0.3);
    }

    .segment.metro {
      background: rgba(168, 85, 247, 0.15);
      border-color: rgba(168, 85, 247, 0.3);
    }

    .segment.suburban {
      background: rgba(251, 146, 60, 0.15);
      border-color: rgba(251, 146, 60, 0.3);
    }

    .segment.transfer {
      background: var(--warn-soft);
      border-color: var(--warn-border);
    }

    .segment.auto {
      background: rgba(251, 191, 36, 0.2);
      border-color: rgba(251, 191, 36, 0.4);
    }

    .ultra-compare {
      margin-top: 8px;
    }

    .ultra-table {
      width: 100%;
      font-size: 9px;
      border-collapse: collapse;
    }

    .ultra-table th,
    .ultra-table td {
      padding: 4px;
      text-align: left;
      border-bottom: 1px solid var(--line);
    }

    .ultra-table th {
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      font-size: 8px;
    }

    .ultra-table td.num {
      text-align: right;
      font-family: monospace;
    }

    .ultra-table tr.best td {
      background: var(--ok-soft);
    }

    .ultra-table .winner {
      color: var(--ok);
      font-weight: 700;
    }

    .ultra-table .coords-cell {
      font-size: 7px;
      font-family: monospace;
      color: var(--muted);
    }

    textarea.log {
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 9px;
      line-height: 1.3;
      min-height: 100px;
      resize: vertical;
      background: var(--bg);
    }

    .map-container {
      flex: 1;
      position: relative;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .hint {
      font-size: 9px;
      color: var(--muted);
      margin-top: 4px;
      line-height: 1.3;
    }

    .hint a {
      color: var(--accent);
    }

    .theme-btn {
      width: auto;
      padding: 5px 8px;
      background: var(--panel2);
      border: 1px solid var(--line);
      font-size: 11px;
    }

    hr {
      border: none;
      border-top: 1px solid var(--line);
      margin: 8px 0;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .modal-overlay.show {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 16px;
      max-width: 650px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
    }

    .modal h3 {
      margin-bottom: 12px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .modal-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      margin-top: 12px;
    }

    .modal-actions button {
      width: auto;
    }

    .help-content {
      font-size: 11px;
      line-height: 1.6;
    }

    .help-content h4 {
      font-size: 12px;
      margin: 12px 0 6px;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .help-content h4:first-child {
      margin-top: 0;
    }

    .help-content p {
      margin-bottom: 8px;
    }

    .help-content ul {
      margin: 6px 0 10px 16px;
    }

    .help-content li {
      margin-bottom: 4px;
    }

    .help-content code {
      background: var(--panel2);
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 10px;
    }

    .help-content .metric-card {
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px;
    }

    .help-content .metric-card h5 {
      font-size: 11px;
      margin-bottom: 3px;
    }

    .help-content .metric-card .formula {
      font-family: monospace;
      font-size: 10px;
      color: var(--accent);
      margin: 3px 0;
    }

    .help-content .metric-card .when {
      font-size: 10px;
      color: var(--ok);
    }

    .help-content .metric-card .warn {
      font-size: 10px;
      color: var(--warn);
    }

    .help-content table {
      width: 100%;
      font-size: 10px;
      border-collapse: collapse;
      margin: 8px 0;
    }

    .help-content table th,
    .help-content table td {
      padding: 4px 6px;
      text-align: left;
      border-bottom: 1px solid var(--line);
    }

    .help-content table th {
      background: var(--panel2);
      font-weight: 600;
    }

    .datetime-row {
      display: flex;
      gap: 4px;
      align-items: flex-end;
    }

    .datetime-row input {
      flex: 1;
    }

    .datetime-buttons {
      display: flex;
      gap: 2px;
    }

    .datetime-buttons button {
      width: auto;
      padding: 6px 8px;
      font-size: 10px;
    }

    .time-mode-toggle {
      display: flex;
      gap: 2px;
      margin-bottom: 4px;
    }

    .time-mode-toggle button {
      flex: 1;
      padding: 4px 8px;
      font-size: 9px;
    }

    .time-mode-toggle button.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .grid-preview-btn {
      padding: 6px;
      font-size: 9px;
    }

    .grid-preview-btn.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .heatmap-toggle {
      margin-top: 4px;
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .heatmap-toggle button {
      flex: 1;
      padding: 6px 10px;
      font-size: 10px;
    }

    .heatmap-toggle button.active {
      background: linear-gradient(90deg, #34d399, #fbbf24, #f87171);
      color: #000;
      border-color: transparent;
    }

    /* Metric radio selector */
    .metric-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 3px;
      margin-top: 4px;
    }

    .metric-radio {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 5px 7px;
      border-radius: 6px;
      border: 1px solid var(--line);
      cursor: pointer;
      transition: all 0.15s;
      font-size: 10px;
    }

    .metric-radio:hover {
      border-color: var(--accent);
      background: var(--panel2);
    }

    .metric-radio:has(input:checked) {
      border-color: var(--accent);
      background: var(--accent);
      color: #fff;
    }

    .metric-radio:has(input:checked) .mr-desc {
      color: rgba(255, 255, 255, 0.8);
    }

    .metric-radio input {
      display: none;
    }

    .metric-radio,
    .return-trip-toggle label {
      text-transform: none;
      margin-bottom: 0;
      font-size: 10px;
      color: var(--text);
    }

    .mr-label {
      font-weight: 600;
      white-space: nowrap;
    }

    .mr-desc {
      font-size: 8px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Point toggle */
    .point-item.disabled {
      opacity: 0.4;
    }

    .point-item.disabled .point-name-input {
      text-decoration: line-through;
    }

    .point-toggle {
      width: 14px;
      height: 14px;
      accent-color: var(--accent);
      cursor: pointer;
      margin-right: 2px;
      flex-shrink: 0;
    }

    .point-return {
      font-size: 8px;
      color: var(--muted);
      margin-top: 1px;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .point-return .return-addr {
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .btn-return {
      font-size: 8px;
      padding: 0 3px;
      border: none;
      background: none;
      color: var(--accent);
      cursor: pointer;
      text-decoration: underline;
      width: auto;
    }

    /* POI search */
    .poi-search-row {
      display: flex;
      gap: 4px;
      margin-bottom: 6px;
    }

    .poi-search-row input {
      flex: 1;
    }

    .poi-search-row button {
      width: auto;
      padding: 6px 10px;
    }

    .poi-actions {
      display: flex;
      gap: 4px;
      margin-bottom: 6px;
      flex-wrap: wrap;
    }

    .poi-badge {
      font-size: 10px;
      padding: 2px 7px;
      border-radius: 10px;
      background: var(--warn-soft);
      border: 1px solid var(--warn-border);
      color: var(--warn);
      font-weight: 700;
    }

    .poi-params {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 4px;
      margin-bottom: 6px;
    }

    .poi-params label {
      font-size: 9px;
      color: var(--muted);
      display: block;
      margin-bottom: 1px;
    }

    .poi-params input {
      width: 100%;
      font-size: 11px;
      padding: 3px 4px;
    }

    .poi-found {
      font-size: 10px;
      color: var(--text);
      padding: 4px 6px;
      background: var(--panel2);
      border-radius: 4px;
      margin-bottom: 6px;
    }

    .poi-found strong {
      color: var(--warn);
    }

    .poi-list {
      max-height: 160px;
      overflow-y: auto;
      margin-top: 6px;
    }

    .poi-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 10px;
      border-bottom: 1px solid var(--line);
      cursor: pointer;
      transition: background 0.15s;
    }

    .poi-item:hover {
      background: var(--panel2);
    }

    .poi-item .poi-icon {
      font-size: 14px;
    }

    .poi-item .poi-name {
      flex: 1;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .poi-item .poi-addr {
      font-size: 9px;
      color: var(--muted);
      max-width: 120px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .poi-item .poi-rating {
      font-size: 9px;
      color: var(--warn);
      font-weight: 700;
    }

    .heatmap-toggle button:disabled {
      opacity: 0.4;
    }

    /* Toast notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
    }

    .toast {
      pointer-events: auto;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 500;
      color: #fff;
      background: var(--panel);
      border: 1px solid var(--line);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      color: var(--text);
      animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 320px;
    }

    .toast.ok {
      border-color: var(--ok-border);
      background: var(--ok-soft);
    }

    .toast.bad {
      border-color: var(--bad-border);
      background: var(--bad-soft);
    }

    .toast.info {
      border-color: var(--accent-border);
      background: var(--accent-soft);
    }

    @keyframes toastIn {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes toastOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    /* Custom confirm dialog */
    .confirm-body {
      font-size: 12px;
      line-height: 1.6;
      margin-bottom: 16px;
      color: var(--text);
    }

    /* Pulse animation for cancel status */
    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .status.cancelling {
      animation: pulse 1s ease-in-out infinite;
    }

    /* Composite weight sliders */
    .weight-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .weight-row label {
      min-width: 25px;
      margin-bottom: 0;
    }

    .weight-row input[type="range"] {
      flex: 1;
      padding: 0;
      height: 4px;
    }

    .weight-row .weight-val {
      font-size: 9px;
      font-family: monospace;
      min-width: 28px;
      text-align: right;
      color: var(--accent);
      font-weight: 700;
    }

    .composite-weights {
      display: none;
      margin-top: 6px;
      padding: 8px;
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 5px;
    }

    .composite-weights.show {
      display: block;
    }

    .composite-weights h4 {
      font-size: 9px;
      color: var(--muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    @media (max-width: 900px) {
      .main {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        max-width: none;
        height: 45vh;
        min-height: 200px;
        resize: vertical;
        border-right: none;
        border-bottom: 1px solid var(--line);
        min-width: unset;
      }

      .map-container {
        height: 55vh;
        flex: 1;
      }

      button {
        min-height: 36px;
        font-size: 12px;
      }

      .btn-sm {
        min-height: 32px;
        padding: 6px 10px;
        font-size: 11px;
      }

      input,
      select,
      textarea {
        min-height: 36px;
        font-size: 13px;
      }

      label {
        font-size: 10px;
      }

      .point-item {
        padding: 8px;
      }

      .card-header {
        padding: 10px 12px;
      }

      .card-header h2 {
        font-size: 12px;
      }

      .card-body {
        padding: 12px;
      }

      header {
        padding: 10px 12px;
      }

      .toast-container {
        bottom: 10px;
        right: 10px;
        left: 10px;
      }

      .toast {
        max-width: none;
      }
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <div>
        <h1>üó∫Ô∏è <span>Fair Meeting Point</span> Finder</h1>
        <div class="subtitle">–û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Å—Ç—Ä–µ—á–∏ —Å —Ä–∞–≤–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –≤ –ø—É—Ç–∏ ‚Ä¢ v3.0</div>
      </div>
      <div class="header-actions">
        <button class="theme-btn" id="themeBtn">üåô</button>
        <button class="theme-btn" id="btnHelp">‚ùì –°–ø—Ä–∞–≤–∫–∞</button>
      </div>
    </header>

    <div class="main">
      <div class="sidebar">
        <div class="sidebar-scroll">
          <!-- API Card -->
          <div class="card" id="cardApi">
            <div class="card-header" onclick="UI.toggleCard('cardApi')">
              <h2>üîë API <span class="badge" id="apiBadge">offline</span></h2>
              <span class="toggle">‚ñº</span>
            </div>
            <div class="card-body">
              <div class="row">
                <div>
                  <label>API –∫–ª—é—á –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç</label>
                  <input type="password" id="apiKey" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á...">
                </div>
                <div style="display:flex;flex-direction:column;justify-content:flex-end;gap:3px;">
                  <button class="btn-sm btn-ghost" id="btnToggleKey">üëÅ</button>
                  <button class="btn-accent btn-sm" id="btnLoadApi">–ü–æ–¥–∫–ª—é—á–∏—Ç—å</button>
                </div>
              </div>
              <div class="status warn" id="apiStatus">‚è≥ –í–≤–µ–¥–∏—Ç–µ API –∫–ª—é—á</div>
              <div class="hint">–ö–ª—é—á —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ. <a href="https://developer.tech.yandex.ru/"
                  target="_blank">–ü–æ–ª—É—á–∏—Ç—å –∫–ª—é—á</a></div>
            </div>
          </div>

          <!-- Points Card -->
          <div class="card" id="cardPoints">
            <div class="card-header" onclick="UI.toggleCard('cardPoints')">
              <h2>üìç –£—á–∞—Å—Ç–Ω–∏–∫–∏ <span class="badge" id="pointsBadge">0</span></h2>
              <span class="toggle">‚ñº</span>
            </div>
            <div class="card-body">
              <div class="row">
                <div>
                  <label>–ê–¥—Ä–µ—Å –∏–ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã</label>
                  <input type="text" id="inputAddr" placeholder="–ú–æ—Å–∫–≤–∞, –¢–≤–µ—Ä—Å–∫–∞—è 1" disabled>
                </div>
                <div>
                  <label>–ò–º—è</label>
                  <input type="text" id="inputName" placeholder="–ê–Ω–¥—Ä–µ–π" disabled>
                </div>
              </div>
              <div class="row">
                <div>
                  <label>–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç</label>
                  <select id="inputTransport" disabled>
                    <option value="masstransit">üöá –û–±—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–π</option>
                    <option value="auto">üöó –ê–≤—Ç–æ–º–æ–±–∏–ª—å</option>
                  </select>
                </div>
                <div style="display:flex;align-items:flex-end;gap:3px;">
                  <button class="btn-accent btn-sm" id="btnAddPoint" disabled>‚ûï</button>
                  <button class="btn-ghost btn-sm" id="btnMyLocation" disabled>üìç</button>
                </div>
              </div>
              <hr>
              <div class="points-list" id="pointsList">
                <div class="empty-state">–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å</div>
              </div>
              <div class="row" style="margin-top:6px;">
                <button class="btn-bad btn-sm" id="btnClearPoints" disabled>üóë –û—á–∏—Å—Ç–∏—Ç—å</button>
                <button class="btn-ghost btn-sm" id="btnFitAll" disabled>üîç –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ</button>
              </div>
            </div>
          </div>

          <!-- Algorithm Card -->
          <div class="card" id="cardAlgo">
            <div class="card-header" onclick="UI.toggleCard('cardAlgo')">
              <h2>‚öôÔ∏è –ê–ª–≥–æ—Ä–∏—Ç–º –ø–æ–∏—Å–∫–∞</h2>
              <span class="toggle">‚ñº</span>
            </div>
            <div class="card-body">
              <label>–ú–µ—Ç—Ä–∏–∫–∞ —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç–∏ <button class="help-btn"
                  onclick="UI.openModal('modalMetrics');event.stopPropagation();">?</button></label>
              <div class="metric-selector" id="metricSelector">
                <label class="metric-radio"><input type="radio" name="metric" value="composite" checked><span
                    class="mr-label">üéØ –ë–∞–ª–∞–Ω—Å</span><span class="mr-desc">—Å–∫–æ—Ä–æ—Å—Ç—å + —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç—å</span></label>
                <label class="metric-radio"><input type="radio" name="metric" value="minimax"><span class="mr-label">‚è±
                    MiniMax</span><span class="mr-desc">–º–∏–Ω. –º–∞–∫—Å. –≤—Ä–µ–º–µ–Ω–∏</span></label>
                <label class="metric-radio"><input type="radio" name="metric" value="range"><span class="mr-label">üìè
                    Range</span><span class="mr-desc">–º–∏–Ω. —Ä–∞–∑–Ω–∏—Ü—ã</span></label>
                <label class="metric-radio"><input type="radio" name="metric" value="nearmetro"><span
                    class="mr-label">üöá NearMetro</span><span class="mr-desc">—É —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞</span></label>
                <label class="metric-radio"><input type="radio" name="metric" value="maxdev"><span class="mr-label">üìä
                    MaxDev</span><span class="mr-desc">–º–∏–Ω. –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è</span></label>
                <label class="metric-radio"><input type="radio" name="metric" value="variance"><span class="mr-label">üìà
                    Variance</span><span class="mr-desc">–º–∏–Ω. –¥–∏—Å–ø–µ—Ä—Å–∏–∏</span></label>
                <label class="metric-radio"><input type="radio" name="metric" value="ultra"><span class="mr-label">üî¨
                    ULTRA</span><span class="mr-desc">—Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö</span></label>
              </div>
              <div class="composite-weights" id="compositeWeights">
                <h4>‚öñÔ∏è –í–µ—Å–∞ composite-–º–µ—Ç—Ä–∏–∫–∏</h4>
                <div class="weight-row"><label>Œ± max</label><input type="range" id="weightAlpha" min="0" max="30"
                    step="1" value="10"><span class="weight-val" id="weightAlphaVal">1.0</span></div>
                <div class="weight-row"><label>Œ≤ std</label><input type="range" id="weightBeta" min="0" max="40"
                    step="1" value="20"><span class="weight-val" id="weightBetaVal">2.0</span></div>
                <div class="weight-row"><label>Œ≥ rng</label><input type="range" id="weightGamma" min="0" max="20"
                    step="1" value="5"><span class="weight-val" id="weightGammaVal">0.5</span></div>
              </div>

              <div class="row">
                <div>
                  <label>–°–µ—Ç–∫–∞ N√óN <button class="help-btn"
                      onclick="UI.openModal('modalGridHelp');event.stopPropagation();">?</button></label>
                  <input type="number" id="gridSize" value="6" min="3" max="12" disabled>
                </div>
                <div>
                  <label>–¢–∞–π–º–∞—É—Ç —Å–µ–∫ <button class="help-btn"
                      onclick="UI.openModal('modalTimeoutHelp');event.stopPropagation();">?</button></label>
                  <input type="number" id="timeout" value="25" min="5" max="60" disabled>
                </div>
              </div>
              <div class="row3">
                <div>
                  <label>–†–∞—Å—à–∏—Ä. H % <button class="help-btn"
                      onclick="UI.openModal('modalExpandHelp');event.stopPropagation();">?</button></label>
                  <input type="number" id="gridExpandH" value="20" min="0" max="100" disabled>
                </div>
                <div>
                  <label>–†–∞—Å—à–∏—Ä. V %</label>
                  <input type="number" id="gridExpandV" value="20" min="0" max="100" disabled>
                </div>
                <div style="display:flex;align-items:flex-end;">
                  <button class="btn-ghost grid-preview-btn" id="btnShowGrid" disabled
                    title="–ü–æ–∫–∞–∑–∞—Ç—å —Å–µ—Ç–∫—É –Ω–∞ –∫–∞—Ä—Ç–µ">üìê</button>
                </div>
              </div>

              <div class="heatmap-toggle">
                <button class="btn-ghost grid-preview-btn" id="btnToggleHeatmap" disabled
                  title="–ü–æ–∫–∞–∑–∞—Ç—å/—Å–∫—Ä—ã—Ç—å —Ç–µ–ø–ª–æ–≤—É—é –∫–∞—Ä—Ç—É">üå°Ô∏è –¢–µ–ø–ª–æ–≤–∞—è –∫–∞—Ä—Ç–∞</button>
                <button class="help-btn" onclick="UI.openModal('modalHeatmapHelp');event.stopPropagation();">?</button>
              </div>

              <div class="full">
                <label>–í—Ä–µ–º—è <button class="help-btn"
                    onclick="UI.openModal('modalTimeHelp');event.stopPropagation();">?</button></label>
                <div class="time-mode-toggle">
                  <button id="btnTimeDeparture" class="active" disabled>üöÄ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</button>
                  <button id="btnTimeArrival" disabled>üèÅ –ü—Ä–∏–±—ã—Ç–∏–µ</button>
                </div>
                <div class="datetime-row">
                  <input type="datetime-local" id="departureTime" disabled>
                  <div class="datetime-buttons">
                    <button class="btn-ghost" id="btnTimeDown" disabled title="‚àí15 –º–∏–Ω">‚óÄ</button>
                    <button class="btn-ghost" id="btnNow" disabled title="–°–µ–π—á–∞—Å">‚è±</button>
                    <button class="btn-ghost" id="btnTimeUp" disabled title="+15 –º–∏–Ω">‚ñ∂</button>
                  </div>
                </div>
                <div class="hint">üñ± –ö–æ–ª–µ—Å–æ –º—ã—à–∏: –≤–≤–µ—Ä—Ö +15 –º–∏–Ω, –≤–Ω–∏–∑ ‚àí15 –º–∏–Ω</div>
              </div>

              <div class="return-trip-toggle"
                style="margin:6px 0;padding:5px 8px;background:var(--panel2);border-radius:6px;display:flex;align-items:center;gap:6px">
                <input type="checkbox" id="chkReturnTrip" style="accent-color:var(--accent);cursor:pointer">
                <label for="chkReturnTrip" style="font-size:10px;cursor:pointer;user-select:none">üîÑ –£—á–∏—Ç—ã–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω—ã–π
                  –ø—É—Ç—å <span style="color:var(--muted)">‚Äî –≤—Ä–µ–º—è —Ç—É–¥–∞ –∏ –æ–±—Ä–∞—Ç–Ω–æ</span></label>
              </div>

              <div class="row">
                <button class="btn-accent btn-lg" id="btnFind" disabled>üîç –ù–∞–π—Ç–∏ —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏</button>
                <button class="btn-bad btn-sm" id="btnCancel" disabled style="width:auto;padding:10px;">‚õî</button>
              </div>

              <div class="status info" id="findStatus">–î–æ–±–∞–≤—å—Ç–µ –º–∏–Ω–∏–º—É–º 2 —É—á–∞—Å—Ç–Ω–∏–∫–∞</div>

              <div class="progress-container" id="progressContainer" style="display:none;">
                <div class="progress-bar">
                  <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text">
                  <span id="progressPhase">–§–∞–∑–∞ 1</span>
                  <span id="progressPct">0%</span>
                </div>
              </div>

              <div class="live-stats" id="liveStats" style="display:none;">
                <div class="live-stat"><span class="icon">üì§</span> –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: <span class="num" id="statSent">0</span>
                </div>
                <div class="live-stat ok"><span class="icon">‚úÖ</span> –£—Å–ø–µ—à–Ω–æ: <span class="num" id="statOk">0</span>
                </div>
                <div class="live-stat bad"><span class="icon">‚ùå</span> –û—à–∏–±–æ–∫: <span class="num" id="statFail">0</span>
                </div>
                <div class="live-stat"><span class="icon">üìä</span> –í—Å–µ–≥–æ: <span class="num"
                    id="statTotal">0</span>/<span class="num" id="statExpected">0</span></div>
              </div>

              <div class="hint">
                <strong>~–ó–∞–ø—Ä–æ—Å–æ–≤:</strong> <span id="estRequests">‚Äî</span> |
                <strong>~–°—Ç–æ–∏–º–æ—Å—Ç—å:</strong> <span id="estCost">–±–µ—Å–ø–ª–∞—Ç–Ω–æ</span>
                <button class="help-btn" onclick="UI.openModal('modalPricing');event.stopPropagation();"
                  style="margin-left:4px;">‚ÇΩ</button>
              </div>
            </div>
          </div>

          <!-- POI Search Card -->
          <div class="card collapsed" id="cardPOI">
            <div class="card-header" onclick="UI.toggleCard('cardPOI')">
              <h2>üè¢ –ü–æ–∏—Å–∫ –º–µ—Å—Ç <span class="badge poi-badge" id="poiBadge">0</span></h2>
              <span class="toggle">‚ñº</span>
            </div>
            <div class="card-body">
              <div class="poi-search-row">
                <input type="text" id="poiQuery" placeholder="–ö–∞—Ñ–µ, —Ä–µ—Å—Ç–æ—Ä–∞–Ω, –ø–∞—Ä–∫..." disabled>
                <button class="btn-accent" id="btnSearchPOI" disabled>üîç</button>
              </div>
              <div class="poi-params">
                <div>
                  <label>–û–±–ª–∞—Å—Ç—å H %</label>
                  <input type="number" id="poiExpandH" value="30" min="0" max="200" disabled>
                </div>
                <div>
                  <label>–û–±–ª–∞—Å—Ç—å V %</label>
                  <input type="number" id="poiExpandV" value="30" min="0" max="200" disabled>
                </div>
                <div>
                  <label>–ú–∞–∫—Å. —Ç–æ—á–µ–∫</label>
                  <input type="number" id="poiMaxResults" value="20" min="5" max="100" step="5" disabled>
                </div>
              </div>
              <div class="poi-found" id="poiFoundInfo" style="display:none"></div>
              <div class="poi-actions">
                <button class="btn-ghost btn-sm" id="btnEvalPOI" disabled>‚≠ê –û—Ü–µ–Ω–∏—Ç—å –∫–∞–∫ —Ç–æ—á–∫–∏ –≤—Å—Ç—Ä–µ—á–∏</button>
                <button class="btn-ghost btn-sm" id="btnLoadMorePOI" disabled>‚ûï –ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â—ë</button>
                <button class="btn-ghost btn-sm" id="btnClearPOI" disabled>üóë –û—á–∏—Å—Ç–∏—Ç—å</button>
              </div>
              <div class="hint">–ù–∞–π–¥–∏—Ç–µ –º–µ—Å—Ç–∞ –≤ –∑–æ–Ω–µ –ø–æ–∏—Å–∫–∞, –∑–∞—Ç–µ–º –æ—Ü–µ–Ω–∏—Ç–µ –∏—Ö –∫–∞–∫ —Ç–æ—á–∫–∏ –≤—Å—Ç—Ä–µ—á–∏</div>
              <div class="poi-list" id="poiList"></div>
            </div>
          </div>

          <!-- Results Card -->
          <div class="card" id="cardResults">
            <div class="card-header" onclick="UI.toggleCard('cardResults')">
              <h2>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã <span class="badge" id="resultsBadge">‚Äî</span></h2>
              <span class="toggle">‚ñº</span>
            </div>
            <div class="card-body">
              <div id="resultsContent">
                <div class="empty-state">–ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø–æ–∏—Å–∫</div>
              </div>
              <div id="ultraCompareContainer" style="display:none;"></div>
              <div class="routes-panel" id="routesPanel" style="display:none;"></div>
            </div>
          </div>

          <!-- Stats Card -->
          <div class="card collapsed" id="cardStats">
            <div class="card-header" onclick="UI.toggleCard('cardStats')">
              <h2>üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Å—Å–∏–∏</h2>
              <span class="toggle">‚ñº</span>
            </div>
            <div class="card-body">
              <div class="chips">
                <div class="chip">üì§ –í—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤: <span class="val" id="chipTotal">0</span></div>
                <div class="chip ok">‚úÖ –£—Å–ø–µ—à–Ω–æ: <span class="val" id="chipOk">0</span></div>
                <div class="chip bad">‚ùå –û—à–∏–±–æ–∫: <span class="val" id="chipFail">0</span></div>
              </div>
              <div class="chips">
                <div class="chip">üó∫Ô∏è –ì–µ–æ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ: <span class="val" id="chipGeo">0</span></div>
                <div class="chip">üõ£Ô∏è –ú–∞—Ä—à—Ä—É—Ç—ã: <span class="val" id="chipRoute">0</span></div>
                <div class="chip warn">‚è± –¢–∞–π–º–∞—É—Ç—ã: <span class="val" id="chipTimeout">0</span></div>
              </div>
              <div class="row" style="margin-top:6px;">
                <button class="btn-ghost btn-sm" id="btnResetStats">üîÑ –°–±—Ä–æ—Å</button>
                <button class="btn-ghost btn-sm" id="btnExportStats">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
              </div>
            </div>
          </div>

          <!-- Debug Card -->
          <div class="card collapsed" id="cardDebug">
            <div class="card-header" onclick="UI.toggleCard('cardDebug')">
              <h2>üêõ –õ–æ–≥</h2>
              <span class="toggle">‚ñº</span>
            </div>
            <div class="card-body">
              <div class="row">
                <button class="btn-ghost btn-sm" id="btnClearLog">üóë –û—á–∏—Å—Ç–∏—Ç—å</button>
                <button class="btn-ghost btn-sm" id="btnCopyLog">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
              </div>
              <textarea class="log" id="logArea" placeholder="–õ–æ–≥ –∑–∞–ø—Ä–æ—Å–æ–≤..."></textarea>
            </div>
          </div>
        </div>
      </div>

      <div class="map-container">
        <div class="toast-container" id="toastContainer"></div>
        <div id="map"></div>
      </div>
    </div>
  </div>

  <!-- Modals -->
  <div class="modal-overlay" id="modalMetrics">
    <div class="modal">
      <h3>üìö –°–ø—Ä–∞–≤–∫–∞ –ø–æ –º–µ—Ç—Ä–∏–∫–∞–º</h3>
      <div class="help-content">
        <p>–ú–µ—Ç—Ä–∏–∫–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –∫–∞–∫ –∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã–±–∏—Ä–∞–µ—Ç "–ª—É—á—à—É—é" —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏.</p>

        <div class="metric-card">
          <h5>‚è± MiniMax ‚Äî –ú–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏</h5>
          <div class="formula">F(p) = max(T‚ÇÅ, T‚ÇÇ, ..., T‚Çô)</div>
          <p>–ò—â–µ—Ç —Ç–æ—á–∫—É, –∫—É–¥–∞ <strong>—Å–∞–º—ã–π –¥–æ–ª–≥–∏–π –ø—É—Ç—å –º–∏–Ω–∏–º–∞–ª–µ–Ω</strong>.</p>
          <div class="when">‚úÖ –ö–æ–≥–¥–∞ –≤–∞–∂–Ω–æ –≤—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è –±—ã—Å—Ç—Ä–µ–µ</div>
        </div>

        <div class="metric-card">
          <h5>üìè Range ‚Äî –ú–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è —Ä–∞–∑–Ω–∏—Ü—ã –≤—Ä–µ–º—ë–Ω</h5>
          <div class="formula">F(p) = max(T) ‚àí min(T)</div>
          <p>–ò—â–µ—Ç —Ç–æ—á–∫—É, –≥–¥–µ <strong>—Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –≤—Ä–µ–º–µ–Ω–∞–º–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–∞</strong>.</p>
          <div class="when">‚úÖ –ö–æ–≥–¥–∞ –≤–∞–∂–Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è "—Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç—å"</div>
          <div class="warn">‚ö†Ô∏è –ú–æ–∂–µ—Ç –¥–∞—Ç—å —Ç–æ—á–∫—É, –≥–¥–µ –≤—Å–µ –µ–¥—É—Ç –¥–æ–ª–≥–æ</div>
        </div>

        <div class="metric-card">
          <h5>üéØ Composite ‚Äî –ë–∞–ª–∞–Ω—Å</h5>
          <div class="formula">F(p) = max(T) + 2¬∑œÉ(T) + 0.5¬∑range(T)</div>
          <p>–ö–æ–º–±–∏–Ω–∏—Ä—É–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç—å –∏ —Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç—å.</p>
          <div class="when">‚úÖ –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ —Å–ª—É—á–∞–µ–≤</div>
        </div>

        <div class="metric-card">
          <h5>üöá NearMetro ‚Äî –ú–∏–Ω–∏–º—É–º –ø–µ—à–µ–π —Ö–æ–¥—å–±—ã</h5>
          <div class="formula">F(p) = composite + Œ£(walk_after_transport)</div>
          <p><strong>–®—Ç—Ä–∞—Ñ—É–µ—Ç —Ç–æ—á–∫–∏</strong>, –¥–æ –∫–æ—Ç–æ—Ä—ã—Ö –Ω—É–∂–Ω–æ –¥–æ–ª–≥–æ –∏–¥—Ç–∏ –ø–µ—à–∫–æ–º –ø–æ—Å–ª–µ –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞.</p>
          <p>–†–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É: –≤—Å–µ –ø—Ä–∏–µ—Ö–∞–ª–∏ –Ω–∞ –æ–¥–Ω–æ –º–µ—Ç—Ä–æ –∏ –µ—â—ë 15 –º–∏–Ω—É—Ç –∏–¥—É—Ç –≤–º–µ—Å—Ç–µ –¥–æ —Ç–æ—á–∫–∏.</p>
          <div class="when">‚úÖ –ö–æ–≥–¥–∞ —Ö–æ—Ç–∏—Ç–µ –≤—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è –ø—Ä—è–º–æ —É —Å—Ç–∞–Ω—Ü–∏–∏/–æ—Å—Ç–∞–Ω–æ–≤–∫–∏</div>
        </div>

        <div class="metric-card">
          <h5>üìä MaxDev ‚Äî –ú–∏–Ω–∏–º—É–º –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –æ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ</h5>
          <div class="formula">F(p) = max(|T·µ¢ ‚àí TÃÑ|)</div>
          <p>–ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ.</p>
          <div class="when">‚úÖ –ö–æ–≥–¥–∞ –≤–∞–∂–Ω–æ, —á—Ç–æ–±—ã –Ω–∏–∫—Ç–æ –Ω–µ –µ—Ö–∞–ª –Ω–∞–º–Ω–æ–≥–æ –¥–æ–ª—å—à–µ —Å—Ä–µ–¥–Ω–µ–≥–æ</div>
        </div>

        <div class="metric-card">
          <h5>üìà Variance ‚Äî –ú–∏–Ω–∏–º—É–º –¥–∏—Å–ø–µ—Ä—Å–∏–∏</h5>
          <div class="formula">F(p) = Œ£(T·µ¢ ‚àí TÃÑ)¬≤ / n</div>
          <p>–ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç <strong>—Ä–∞–∑–±—Ä–æ—Å –≤—Ä–µ–º—ë–Ω</strong> –≤–æ–∫—Ä—É–≥ —Å—Ä–µ–¥–Ω–µ–≥–æ.</p>
          <div class="when">‚úÖ –ö–æ–≥–¥–∞ –≤–∞–∂–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –æ–¥–Ω–æ—Ä–æ–¥–Ω–æ—Å—Ç—å –≤—Ä–µ–º—ë–Ω</div>
          <div class="warn">‚ö†Ô∏è –ú–µ–Ω–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –∫ –≤—ã–±—Ä–æ—Å–∞–º —á–µ–º MaxDev</div>
        </div>

        <div class="metric-card">
          <h5>üî¨ ULTRA ‚Äî –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –º–µ—Ç—Ä–∏–∫</h5>
          <p>–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –í–°–ï –º–µ—Ç—Ä–∏–∫–∏ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω—É—é —Ç–∞–±–ª–∏—Ü—É —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ —Ç–æ—á–µ–∫.</p>
          <div class="when">‚úÖ –î–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è —Ä–∞–∑–Ω–∏—Ü—ã –º–µ–∂–¥—É –º–µ—Ç—Ä–∏–∫–∞–º–∏</div>
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalMetrics')">–ü–æ–Ω—è—Ç–Ω–æ</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalTimeHelp">
    <div class="modal">
      <h3>üïê –í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è / –ø—Ä–∏–±—ã—Ç–∏—è</h3>
      <div class="help-content">
        <p>–í—Ä–µ–º—è –≤–ª–∏—è–µ—Ç –Ω–∞ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ü–µ–Ω–∫—É –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç–∏ –¥–æ—Ä–æ–≥.</p>
        <p class="hint">–í –±—Ä–∞—É–∑–µ—Ä–Ω–æ–π JS-API –Ω–µ–ª—å–∑—è —Ç–æ—á–Ω–æ –∑–∞–¥–∞—Ç—å –≤—Ä–µ–º—è –≤—ã–µ–∑–¥–∞, –ø–æ—ç—Ç–æ–º—É –º–∞—Ä—à—Ä—É—Ç—ã —Å—Ç—Ä–æ—è—Ç—Å—è –ø–æ —Ç–µ–∫—É—â–µ–π
          —Å–∏—Ç—É–∞—Ü–∏–∏, –∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞—Å—á—ë—Ç–∞ –∏ –∫—ç—à–∞.</p>

        <h4>üöÄ –í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è</h4>
        <p>–í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ <strong>–≤—ã–µ–∑–∂–∞—é—Ç</strong> –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è. –í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è —É –≤—Å–µ—Ö –±—É–¥–µ—Ç —Ä–∞–∑–Ω—ã–º.</p>

        <h4>üèÅ –í—Ä–µ–º—è –ø—Ä–∏–±—ã—Ç–∏—è</h4>
        <p>–í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –¥–æ–ª–∂–Ω—ã <strong>–ø—Ä–∏–µ—Ö–∞—Ç—å</strong> –∫ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏. –í—Ä–µ–º—è –≤—ã–µ–∑–¥–∞ —É –≤—Å–µ—Ö –±—É–¥–µ—Ç —Ä–∞–∑–Ω—ã–º.</p>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalTimeHelp')">–ü–æ–Ω—è—Ç–Ω–æ</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalPricing">
    <div class="modal">
      <h3>üí∞ –¢–∞—Ä–∏—Ñ—ã Yandex Maps API</h3>
      <div class="help-content">
        <h4>üÜì –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Ç–∞—Ä–∏—Ñ</h4>
        <ul>
          <li>–î–æ <strong>25 000 –∑–∞–ø—Ä–æ—Å–æ–≤/—Å—É—Ç–∫–∏</strong> ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω–æ</li>
          <li>–ë–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Å—Ä–æ–∫—É –¥–µ–π—Å—Ç–≤–∏—è</li>
          <li>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è: —Ç–æ–ª—å–∫–æ –Ω–µ–∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ</li>
        </ul>

        <h4>üí≥ –ü–ª–∞—Ç–Ω—ã–µ —Ç–∞—Ä–∏—Ñ—ã (–ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –∏–ª–∏ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ)</h4>
        <table>
          <tr>
            <th>–õ–∏–º–∏—Ç/—Å—É—Ç–∫–∏</th>
            <th>–¶–µ–Ω–∞/–≥–æ–¥</th>
            <th>–ó–∞ 1 –∑–∞–ø—Ä–æ—Å</th>
            <th>–ó–∞ 1000 –∑–∞–ø—Ä–æ—Å–æ–≤</th>
          </tr>
          <tr>
            <td>1 000</td>
            <td>195 000‚ÇΩ</td>
            <td>~0.53‚ÇΩ</td>
            <td>~534‚ÇΩ</td>
          </tr>
          <tr>
            <td>10 000</td>
            <td>585 000‚ÇΩ</td>
            <td>~0.16‚ÇΩ</td>
            <td>~160‚ÇΩ</td>
          </tr>
          <tr>
            <td>25 000</td>
            <td>1 105 000‚ÇΩ</td>
            <td>~0.12‚ÇΩ</td>
            <td>~121‚ÇΩ</td>
          </tr>
          <tr>
            <td>100 000</td>
            <td>2 184 000‚ÇΩ</td>
            <td>~0.06‚ÇΩ</td>
            <td>~60‚ÇΩ</td>
          </tr>
        </table>

        <h4>üßÆ –ü—Ä–∏–º–µ—Ä–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞ –≤ FMPF</h4>
        <table>
          <tr>
            <th>–°–µ—Ç–∫–∞</th>
            <th>–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤</th>
            <th>–ó–∞–ø—Ä–æ—Å–æ–≤</th>
            <th>–°—Ç–æ–∏–º–æ—Å—Ç—å*</th>
          </tr>
          <tr>
            <td>6√ó6</td>
            <td>2</td>
            <td>~74</td>
            <td>–±–µ—Å–ø–ª–∞—Ç–Ω–æ / ~12‚ÇΩ</td>
          </tr>
          <tr>
            <td>6√ó6</td>
            <td>3</td>
            <td>~111</td>
            <td>–±–µ—Å–ø–ª–∞—Ç–Ω–æ / ~18‚ÇΩ</td>
          </tr>
          <tr>
            <td>8√ó8</td>
            <td>3</td>
            <td>~195</td>
            <td>–±–µ—Å–ø–ª–∞—Ç–Ω–æ / ~31‚ÇΩ</td>
          </tr>
          <tr>
            <td>10√ó10</td>
            <td>4</td>
            <td>~404</td>
            <td>–±–µ—Å–ø–ª–∞—Ç–Ω–æ / ~65‚ÇΩ</td>
          </tr>
        </table>
        <p style="font-size:9px;color:var(--muted);">* –±–µ—Å–ø–ª–∞—Ç–Ω–æ –ø—Ä–∏ –ª–∏–º–∏—Ç–µ 25–∫/—Å—É—Ç–∫–∏, –∏–Ω–∞—á–µ –ø–æ —Ç–∞—Ä–∏—Ñ—É 10–∫
          –∑–∞–ø—Ä–æ—Å–æ–≤/—Å—É—Ç–∫–∏</p>

        <p style="margin-top:10px;"><a href="https://yandex.ru/dev/jsapi-v2-1/doc/ru/tariffs/" target="_blank">–ü–æ–ª–Ω—ã–µ
            —Ç–∞—Ä–∏—Ñ—ã –Ω–∞ —Å–∞–π—Ç–µ –Ø–Ω–¥–µ–∫—Å–∞ ‚Üí</a></p>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalPricing')">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalGridHelp">
    <div class="modal">
      <h3>üìê –°–µ—Ç–∫–∞ N√óN</h3>
      <div class="help-content">
        <p>–†–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞.</p>
        <ul>
          <li><strong>6√ó6</strong> = 36 —Ç–æ—á–µ–∫ ‚Äî –±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫, –¥–æ—Å—Ç–∞—Ç–æ—á–µ–Ω –¥–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ —Å–ª—É—á–∞–µ–≤</li>
          <li><strong>8√ó8</strong> = 64 —Ç–æ—á–∫–∏ ‚Äî –±–æ–ª–µ–µ —Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫</li>
          <li><strong>10√ó10</strong> = 100 —Ç–æ—á–µ–∫ ‚Äî –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫, –±–æ–ª—å—à–µ –∑–∞–ø—Ä–æ—Å–æ–≤</li>
          <li><strong>12√ó12</strong> = 144 —Ç–æ—á–∫–∏ ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è</li>
        </ul>
        <p>–ß–µ–º –±–æ–ª—å—à–µ —Å–µ—Ç–∫–∞, —Ç–µ–º –±–æ–ª—å—à–µ –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ API –∏ –¥–æ–ª—å—à–µ –ø–æ–∏—Å–∫.</p>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalGridHelp')">–ü–æ–Ω—è—Ç–Ω–æ</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalExpandHelp">
    <div class="modal">
      <h3>‚ÜîÔ∏è –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –æ–±–ª–∞—Å—Ç–∏ –ø–æ–∏—Å–∫–∞</h3>
      <div class="help-content">
        <p>–†–∞—Å—à–∏—Ä—è–µ—Ç –æ–±–ª–∞—Å—Ç—å –ø–æ–∏—Å–∫–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã —Ç–æ—á–µ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.</p>
        <ul>
          <li><strong>H %</strong> ‚Äî —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏ (–¥–æ–ª–≥–æ—Ç–∞, –≤–æ—Å—Ç–æ–∫-–∑–∞–ø–∞–¥)</li>
          <li><strong>V %</strong> ‚Äî —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ (—à–∏—Ä–æ—Ç–∞, —Å–µ–≤–µ—Ä-—é–≥)</li>
        </ul>
        <p><strong>–ü—Ä–∏–º–µ—Ä—ã:</strong></p>
        <ul>
          <li><strong>0%</strong> ‚Äî –æ–±–ª–∞—Å—Ç—å –ø–æ–∏—Å–∫–∞ —Ç–æ—á–Ω–æ –º–µ–∂–¥—É —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏</li>
          <li><strong>20%</strong> ‚Äî –Ω–µ–º–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ —Ç–æ—á–∫–∏ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)</li>
          <li><strong>50%</strong> ‚Äî –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ —Å—Ç–æ—Ä–æ–Ω–µ</li>
          <li><strong>100%</strong> ‚Äî —É–¥–≤–æ–µ–Ω–Ω–∞—è –æ–±–ª–∞—Å—Ç—å –ø–æ–∏—Å–∫–∞</li>
        </ul>
        <p>–†–∞–∑–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è H –∏ V –ø–æ–ª–µ–∑–Ω—ã, –µ—Å–ª–∏ —Ç–æ—á–∫–∏ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω—ã –≤—ã—Ç—è–Ω—É—Ç–æ.</p>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalExpandHelp')">–ü–æ–Ω—è—Ç–Ω–æ</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalTimeoutHelp">
    <div class="modal">
      <h3>‚è± –¢–∞–π–º–∞—É—Ç</h3>
      <div class="help-content">
        <p>–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –æ—Ç API –¥–ª—è –æ–¥–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞.</p>
        <ul>
          <li><strong>15 —Å–µ–∫</strong> ‚Äî –±—ã—Å—Ç—Ä–æ, –Ω–æ –º–æ–∂–µ—Ç –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Å–ª–æ–∂–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã</li>
          <li><strong>25 —Å–µ–∫</strong> ‚Äî –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)</li>
          <li><strong>40-60 —Å–µ–∫</strong> ‚Äî –¥–ª—è –º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞ –∏–ª–∏ —Å–ª–æ–∂–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤</li>
        </ul>
        <p>–ï—Å–ª–∏ –º–Ω–æ–≥–æ —Ç–∞–π–º–∞—É—Ç–æ–≤ –≤ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ ‚Äî —É–≤–µ–ª–∏—á—å—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ.</p>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalTimeoutHelp')">–ü–æ–Ω—è—Ç–Ω–æ</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalHeatmapHelp">
    <div class="modal">
      <h3>üå°Ô∏è –¢–µ–ø–ª–æ–≤–∞—è –∫–∞—Ä—Ç–∞</h3>
      <div class="help-content">
        <p>–¢–µ–ø–ª–æ–≤–∞—è –∫–∞—Ä—Ç–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ—Ö —Ç–æ—á–µ–∫ —Å–µ—Ç–∫–∏.</p>

        <h4>üé® –¶–≤–µ—Ç–∞</h4>
        <ul>
          <li><span style="color:#34d399;">üü¢ –ó–µ–ª—ë–Ω—ã–π</span> ‚Äî –æ—Ç–ª–∏—á–Ω—ã–µ —Ç–æ—á–∫–∏ (–Ω–∏–∑–∫–∏–π score)</li>
          <li><span style="color:#fbbf24;">üü° –ñ—ë–ª—Ç—ã–π</span> ‚Äî —Å—Ä–µ–¥–Ω–∏–µ —Ç–æ—á–∫–∏</li>
          <li><span style="color:#f87171;">üî¥ –ö—Ä–∞—Å–Ω—ã–π</span> ‚Äî –ø–ª–æ—Ö–∏–µ —Ç–æ—á–∫–∏ (–≤—ã—Å–æ–∫–∏–π score)</li>
        </ul>

        <h4>üìä –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤ —è—á–µ–π–∫–µ</h4>
        <p>–ö–ª–∏–∫ –ø–æ —è—á–µ–π–∫–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç:</p>
        <ul>
          <li>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ—á–∫–∏</li>
          <li>–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –≤ –ø—É—Ç–∏</li>
          <li>–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è</li>
          <li>–†–∞–∑–Ω–∏—Ü–∞ (max ‚àí min)</li>
          <li>–í—Ä–µ–º—è –∫–∞–∂–¥–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞</li>
        </ul>

        <h4>üí° –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ</h4>
        <p>–í–∫–ª—é—á–∞–π—Ç–µ/–≤—ã–∫–ª—é—á–∞–π—Ç–µ –∫–Ω–æ–ø–∫–æ–π –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞. –ö–∞—Ä—Ç–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –¥–æ –Ω–æ–≤–æ–≥–æ –ø–æ–∏—Å–∫–∞.</p>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalHeatmapHelp')">–ü–æ–Ω—è—Ç–Ω–æ</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalConfirm">
    <div class="modal">
      <h3 id="confirmTitle">‚ö†Ô∏è –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</h3>
      <div class="confirm-body" id="confirmBody"></div>
      <div class="modal-actions">
        <button class="btn-ghost" id="confirmCancel">–û—Ç–º–µ–Ω–∞</button>
        <button class="btn-accent" id="confirmOk">OK</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="modalHelp">
    <div class="modal">
      <h3>‚ùì –°–ø—Ä–∞–≤–∫–∞</h3>
      <div class="help-content">
        <h4>üéØ –ß—Ç–æ –¥–µ–ª–∞–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ?</h4>
        <p>–ù–∞—Ö–æ–¥–∏—Ç —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏, –∫—É–¥–∞ –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º –µ—Ö–∞—Ç—å –ø—Ä–∏–º–µ—Ä–Ω–æ –æ–¥–∏–Ω–∞–∫–æ–≤–æ –ø–æ –≤—Ä–µ–º–µ–Ω–∏.</p>

        <h4>üöÄ –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å?</h4>
        <ol>
          <li>–í–≤–µ–¥–∏—Ç–µ API –∫–ª—é—á –∏ –Ω–∞–∂–º–∏—Ç–µ "–ü–æ–¥–∫–ª—é—á–∏—Ç—å"</li>
          <li>–î–æ–±–∞–≤—å—Ç–µ —Ç–æ—á–∫–∏: –∫–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å</li>
          <li>–ù–∞–∂–º–∏—Ç–µ "–ù–∞–π—Ç–∏ —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏"</li>
          <li>–ù–∞ –∫–∞—Ä—Ç–µ –ø–æ—è–≤—è—Ç—Å—è –¢–û–ü-5 —Ç–æ—á–µ–∫ ‚Äî –∫–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –ª—é–±—É—é –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π</li>
          <li>–ï—Å–ª–∏ –Ω—É–∂–Ω–æ –±–æ–ª—å—à–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ ‚Äî –Ω–∞–∂–º–∏—Ç–µ "–ü–æ–∫–∞–∑–∞—Ç—å –µ—â—ë"</li>
        </ol>

        <h4>üìê –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ç–∫–∏</h4>
        <p>–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É <strong>üìê</strong> —Ä—è–¥–æ–º —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ —Å–µ—Ç–∫–∏, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å:</p>
        <ul>
          <li>–°–∏–Ω–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ ‚Äî –æ–±–ª–∞—Å—Ç—å –ø–æ–∏—Å–∫–∞</li>
          <li>–°–µ—Ä—ã–µ —Ç–æ—á–∫–∏ ‚Äî –∫–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏</li>
        </ul>

        <h4>üå°Ô∏è –¢–µ–ø–ª–æ–≤–∞—è –∫–∞—Ä—Ç–∞</h4>
        <p>–í–∫–ª—é—á–∏—Ç–µ –≥–∞–ª–æ—á–∫—É "–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–ø–ª–æ–≤—É—é –∫–∞—Ä—Ç—É" –ø–µ—Ä–µ–¥ –ø–æ–∏—Å–∫–æ–º, —á—Ç–æ–±—ã –ø–æ—Å–ª–µ —É–≤–∏–¥–µ—Ç—å:</p>
        <ul>
          <li><span style="color:#34d399;">üü¢ –ó–µ–ª—ë–Ω—ã–µ –∑–æ–Ω—ã</span> ‚Äî –ª—É—á—à–∏–µ —Ç–æ—á–∫–∏ (–º–∞–ª–æ–µ –≤—Ä–µ–º—è)</li>
          <li><span style="color:#fbbf24;">üü° –ñ—ë–ª—Ç—ã–µ –∑–æ–Ω—ã</span> ‚Äî —Å—Ä–µ–¥–Ω–∏–µ —Ç–æ—á–∫–∏</li>
          <li><span style="color:#f87171;">üî¥ –ö—Ä–∞—Å–Ω—ã–µ –∑–æ–Ω—ã</span> ‚Äî –ø–ª–æ—Ö–∏–µ —Ç–æ—á–∫–∏ (–¥–æ–ª–≥–æ–µ –≤—Ä–µ–º—è)</li>
        </ul>

        <h4>üöá –ú–µ—Ç—Ä–∏–∫–∞ NearMetro</h4>
        <p>–®—Ç—Ä–∞—Ñ—É–µ—Ç —Ç–æ—á–∫–∏, –≥–¥–µ –ø–æ—Å–ª–µ –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –Ω—É–∂–Ω–æ –¥–æ–ª–≥–æ –∏–¥—Ç–∏ –ø–µ—à–∫–æ–º. –†–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É "–≤—Å–µ –ø—Ä–∏–µ—Ö–∞–ª–∏ –Ω–∞ –æ–¥–Ω–æ
          –º–µ—Ç—Ä–æ –∏ –µ—â—ë –∏–¥—É—Ç 15 –º–∏–Ω—É—Ç –≤–º–µ—Å—Ç–µ".</p>

        <h4>üìä –ñ–∏–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h4>
        <p>–í–æ –≤—Ä–µ–º—è –ø–æ–∏—Å–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è: —Å–∫–æ–ª—å–∫–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ, —É—Å–ø–µ—à–Ω–æ, —Å –æ—à–∏–±–∫–∞–º–∏.</p>
      </div>
      <div class="modal-actions">
        <button class="btn-accent" onclick="UI.closeModal('modalHelp')">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      const COLORS = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'];
      const RESULT_COLORS = ['#fbbf24', '#94a3b8', '#d97706', '#6b7280', '#6b7280'];
      const METRIC_NAMES = { minimax: 'MiniMax', range: 'Range', composite: 'Composite', maxdev: 'MaxDev', variance: 'Variance', nearmetro: 'NearMetro' };

      const CONSTANTS = {
        ESTIMATED_PENALTY: 300,
        WALK_NEAR_TRANSPORT_THRESHOLD: 180,
        WALK_EXTRA_DISPLAY_THRESHOLD: 60,
        ROUTE_DISPLAY_DELAY_MS: 80,
        RETRY_DELAY_MS: 1000,
        GOLDEN_SECTION_RADIUS_M: 500,
        GOLDEN_SECTION_STEPS: 4,
        BATCH_SIZE: 3,
        DEBOUNCE_MS: 300,
        TOAST_DURATION_MS: 3000,
        CACHE_VERSION: 'v2'
      };

      const State = {
        apiLoaded: false, map: null, points: [],
        allResults: [],
        results: [],
        resultMarkers: [],
        selectedResultIndex: 0,
        routeObjects: [],
        gridPreviewObjects: [],
        heatmapObjects: [],
        showingGrid: false,
        showingHeatmap: false,
        heatmapData: null,
        runId: 0, running: false, cancelled: false, theme: 'dark',
        timeMode: 'departure',
        displayCount: 5,
        currentSearch: {
          sent: 0, ok: 0, fail: 0, expected: 0, cached: 0, estimated: 0, startTime: 0
        },
        stats: {
          geocode: { total: 0, ok: 0, fail: 0 },
          route: { total: 0, ok: 0, fail: 0, timeout: 0 }
        },
        history: [],
        ultraResults: null,
        routeCache: new Map(),
        routeCacheDirty: false,
        routeLimiter: null,
        returnTrip: false,
        compositeWeights: { alpha: 1.0, beta: 2.0, gamma: 0.5 },
        poiResults: [],
        poiMarkers: [],
        poiTotalFound: 0,
        poiLastQuery: '',
        poiLastBbox: null,
        settings: {
          maxConcurrentRoutes: 5,
          refineTopK: 5,
          localGridSize: 3,
          hillSteps: 6,
          hillMinStepM: 120
        }
      };

      const $ = id => document.getElementById(id);
      const DOM = {};

      const Utils = {
        uuid: () => crypto?.randomUUID?.() || `${Date.now()}-${Math.random().toString(36).slice(2)}`,
        now: () => new Date().toLocaleTimeString('ru-RU', { hour12: false }) + '.' + String(Date.now() % 1000).padStart(3, '0'),
        fmtCoord: c => `${c[0].toFixed(5)}, ${c[1].toFixed(5)}`,
        fmtCoordShort: c => `${c[0].toFixed(4)}, ${c[1].toFixed(4)}`,
        secToStr: s => { s = Math.max(0, Math.round(s)); const h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60); return h > 0 ? `${h}—á ${m}–º` : `${m} –º–∏–Ω`; },
        secToStrShort: s => { s = Math.max(0, Math.round(s)); const m = Math.floor(s / 60); return `${m}–º`; },
        clamp: (v, min, max, def) => { const n = parseInt(v, 10); return Number.isFinite(n) ? Math.min(max, Math.max(min, n)) : def; },
        escHtml: s => { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; },
        escAttr: s => String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;'),
        copyToClipboard: async text => { try { await navigator.clipboard.writeText(text); return true; } catch { return false; } },
        toLocalISOString: date => {
          const pad = n => String(n).padStart(2, '0');
          return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
        },
        toast: (msg, type = 'info') => {
          const container = $('toastContainer');
          if (!container) return;
          const el = document.createElement('div');
          el.className = `toast ${type}`;
          el.textContent = msg;
          container.appendChild(el);
          setTimeout(() => { try { container.removeChild(el); } catch { } }, CONSTANTS.TOAST_DURATION_MS);
        },
        customConfirm: (title, message) => new Promise(resolve => {
          const overlay = $('modalConfirm');
          if (!overlay) { resolve(confirm(message)); return; }
          $('confirmTitle').textContent = title;
          $('confirmBody').textContent = message;
          overlay.classList.add('show');
          const cleanup = result => { overlay.classList.remove('show'); resolve(result); };
          $('confirmOk').onclick = () => cleanup(true);
          $('confirmCancel').onclick = () => cleanup(false);
          overlay.onclick = e => { if (e.target === overlay) cleanup(false); };
        }),
        debounce: (fn, ms) => { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); }; },
        parseCoords: text => {
          const m = text.trim().match(/^\s*(-?\d+\.?\d*)\s*[,;\s]\s*(-?\d+\.?\d*)\s*$/);
          if (!m) return null;
          const lat = parseFloat(m[1]), lon = parseFloat(m[2]);
          if (Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
          return [lat, lon];
        },
        calcETA: () => {
          const s = State.currentSearch;
          if (s.sent <= 0 || !s.startTime) return null;
          const elapsed = (Date.now() - s.startTime) / 1000;
          const rate = s.sent / elapsed;
          const remaining = Math.max(0, s.expected - s.sent);
          return remaining > 0 && rate > 0 ? Math.ceil(remaining / rate) : null;
        },
        // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è —Ü–≤–µ—Ç–∞ –æ—Ç –∑–µ–ª—ë–Ω–æ–≥–æ –∫ –∫—Ä–∞—Å–Ω–æ–º—É
        scoreToColor: (score, minScore, maxScore) => {
          const t = Math.min(1, Math.max(0, (score - minScore) / (maxScore - minScore || 1)));
          const r = Math.round(52 + t * (248 - 52));
          const g = Math.round(211 - t * (211 - 113));
          const b = Math.round(153 - t * (153 - 113));
          return `rgba(${r},${g},${b},0.5)`;
        },
        toRad: d => d * Math.PI / 180,
        haversineM: (a, b) => {
          const r = 6371000;
          const lat1 = Utils.toRad(a[0]), lat2 = Utils.toRad(b[0]);
          const dLat = Utils.toRad(b[0] - a[0]);
          const dLon = Utils.toRad(b[1] - a[1]);
          const sinLat = Math.sin(dLat / 2);
          const sinLon = Math.sin(dLon / 2);
          const h = sinLat * sinLat + Math.cos(lat1) * Math.cos(lat2) * sinLon * sinLon;
          return 2 * r * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
        },
        metersToLat: m => m / 111320,
        metersToLon: (m, lat) => m / (111320 * Math.cos(Utils.toRad(lat)) || 1),
        coordKey: (c, precision = 5) => `${c[0].toFixed(precision)},${c[1].toFixed(precision)}`,
        isValidCoord: c => Array.isArray(c) && c.length === 2 && Number.isFinite(c[0]) && Number.isFinite(c[1]) && Math.abs(c[0]) <= 90 && Math.abs(c[1]) <= 180,
        getSelectedMetric: () => {
          const checked = document.querySelector('input[name="metric"]:checked');
          return checked?.value || 'composite';
        },
        getSearchTime: () => {
          if (DOM.departureTime?.value) {
            const d = new Date(DOM.departureTime.value);
            if (!Number.isNaN(d.getTime())) return d;
          }
          return new Date();
        },
        timeBucket: (date, minutes) => {
          const ms = minutes * 60 * 1000;
          return Math.floor(date.getTime() / ms) * ms;
        },
        isPeakHour: date => {
          const h = date.getHours();
          return (h >= 7 && h <= 10) || (h >= 16 && h <= 20);
        },
        getCacheTtlMs: date => {
          const isWeekend = date.getDay() === 0 || date.getDay() === 6;
          if (isWeekend) return 20 * 60 * 1000;
          return Utils.isPeakHour(date) ? 5 * 60 * 1000 : 15 * 60 * 1000;
        },
        estimateDurationSec: (from, to, transport, date) => {
          const distKm = Utils.haversineM(from, to) / 1000;
          const peak = Utils.isPeakHour(date);
          let speed = 25;
          if (transport === 'auto') speed = peak ? 22 : 36;
          else speed = peak ? 16 : 22;
          return Math.max(60, (distKm / Math.max(5, speed)) * 3600);
        },
        createLimiter: limit => {
          let active = 0;
          const queue = [];
          const next = () => {
            if (active >= limit || queue.length === 0) return;
            const job = queue.shift();
            active++;
            job.fn().then(
              res => { active--; job.resolve(res); next(); },
              err => { active--; job.reject(err); next(); }
            );
          };
          return fn => new Promise((resolve, reject) => {
            queue.push({ fn, resolve, reject });
            next();
          });
        }
      };

      const Math2 = {
        mean: arr => arr.reduce((a, b) => a + b, 0) / arr.length,
        variance: arr => { const m = Math2.mean(arr); return arr.reduce((a, v) => a + (v - m) ** 2, 0) / arr.length; },
        std: arr => Math.sqrt(Math2.variance(arr)),
        range: arr => Math.max(...arr) - Math.min(...arr),
        maxDev: arr => { const m = Math2.mean(arr); return Math.max(...arr.map(v => Math.abs(v - m))); },

        calcMetrics: durations => {
          const n = durations.length, sum = durations.reduce((a, b) => a + b, 0), mean = sum / n;
          const min = Math.min(...durations), max = Math.max(...durations), range = max - min;
          const variance = durations.reduce((a, v) => a + (v - mean) ** 2, 0) / n, std = Math.sqrt(variance);
          const maxDev = Math.max(...durations.map(v => Math.abs(v - mean)));
          return { mean, min, max, range, variance, std, maxDev, sum };
        },

        // –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—É–º–º–∞—Ä–Ω–æ–µ –≤—Ä–µ–º—è –ø–µ—à–µ–π —Ö–æ–¥—å–±—ã –ü–û–°–õ–ï –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞
        calcWalkAfterTransport: routes => {
          let totalWalk = 0;
          let maxWalk = 0;

          routes.forEach(r => {
            // –ù–∞—Ö–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ (–Ω–µ –ø–µ—à–∫–æ–º)
            let lastTransportIdx = -1;
            r.segments.forEach((s, i) => {
              if (s.type !== 'walk' && s.type !== 'transfer') {
                lastTransportIdx = i;
              }
            });

            // –°—É–º–º–∏—Ä—É–µ–º –ø–µ—à—É—é —Ö–æ–¥—å–±—É –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞
            let walkAfter = 0;
            if (lastTransportIdx >= 0) {
              for (let i = lastTransportIdx + 1; i < r.segments.length; i++) {
                if (r.segments[i].type === 'walk') {
                  walkAfter += r.segments[i].duration;
                }
              }
            }

            r.walkAfterTransport = walkAfter;
            totalWalk += walkAfter;
            maxWalk = Math.max(maxWalk, walkAfter);
          });

          return { totalWalk, maxWalk };
        },

        weightedCentroid: points => {
          const weights = points.map(p => Number.isFinite(p.weight) ? p.weight : 1);
          const sumW = weights.reduce((a, b) => a + b, 0) || 1;
          const lat = points.reduce((a, p, i) => a + p.coords[0] * weights[i], 0) / sumW;
          const lon = points.reduce((a, p, i) => a + p.coords[1] * weights[i], 0) / sumW;
          return [lat, lon];
        },

        toXY: (coords, refLat) => {
          const r = 6371000;
          const lat = Utils.toRad(coords[0]);
          const lon = Utils.toRad(coords[1]);
          const ref = Utils.toRad(refLat);
          return [r * lon * Math.cos(ref), r * lat];
        },

        fromXY: (xy, refLat) => {
          const r = 6371000;
          const ref = Utils.toRad(refLat);
          const lat = (xy[1] / r) * (180 / Math.PI);
          const lon = (xy[0] / (r * Math.cos(ref) || 1)) * (180 / Math.PI);
          return [lat, lon];
        },

        geometricMedian: (points, maxIter = 40, tolM = 20) => {
          if (!points.length) return [0, 0];
          const refLat = Math2.mean(points.map(p => p.coords[0]));
          const weights = points.map(p => Number.isFinite(p.weight) ? p.weight : 1);
          const xyPoints = points.map(p => Math2.toXY(p.coords, refLat));
          let current = Math2.toXY(Math2.weightedCentroid(points), refLat);
          for (let iter = 0; iter < maxIter; iter++) {
            let numX = 0, numY = 0, den = 0;
            let stuck = false;
            for (let i = 0; i < points.length; i++) {
              const xy = xyPoints[i];
              const dx = current[0] - xy[0];
              const dy = current[1] - xy[1];
              const dist = Math.hypot(dx, dy);
              if (dist < tolM) { current = xy; stuck = true; break; }
              const w = weights[i];
              numX += w * xy[0] / dist;
              numY += w * xy[1] / dist;
              den += w / dist;
            }
            if (stuck || den === 0) break;
            const next = [numX / den, numY / den];
            if (Math.hypot(next[0] - current[0], next[1] - current[1]) < tolM) { current = next; break; }
            current = next;
          }
          return Math2.fromXY(current, refLat);
        },

        centroid: points => {
          const n = points.length;
          return [points.reduce((a, p) => a + p.coords[0], 0) / n, points.reduce((a, p) => a + p.coords[1], 0) / n];
        },

        bbox: (points, expandH = 0, expandV = 0) => {
          const lats = points.map(p => p.coords[0]), lons = points.map(p => p.coords[1]);
          let minLat = Math.min(...lats), maxLat = Math.max(...lats), minLon = Math.min(...lons), maxLon = Math.max(...lons);
          const padLat = (maxLat - minLat) * expandV / 100 || 0.01, padLon = (maxLon - minLon) * expandH / 100 || 0.015;
          return { minLat: minLat - padLat, maxLat: maxLat + padLat, minLon: minLon - padLon, maxLon: maxLon + padLon };
        },

        generateGrid: (points, gridSize, expandH, expandV) => {
          const bbox = Math2.bbox(points, expandH, expandV), centroid = Math2.centroid(points);
          const candidates = [centroid];
          for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
              const lat = bbox.minLat + ((i + 0.5) / gridSize) * (bbox.maxLat - bbox.minLat);
              const lon = bbox.minLon + ((j + 0.5) / gridSize) * (bbox.maxLon - bbox.minLon);
              candidates.push([lat, lon]);
            }
          }
          return candidates;
        },

        gridStep: (bbox, gridSize) => {
          const latStep = (bbox.maxLat - bbox.minLat) / gridSize || 0.01;
          const lonStep = (bbox.maxLon - bbox.minLon) / gridSize || 0.015;
          return { latStep, lonStep };
        },

        generateLocalGrid: (center, latStep, lonStep, gridSize) => {
          let size = Math.max(3, gridSize | 0);
          if (size % 2 === 0) size += 1;
          const r = Math.floor(size / 2);
          const candidates = [];
          for (let i = -r; i <= r; i++) {
            for (let j = -r; j <= r; j++) {
              candidates.push([center[0] + i * latStep, center[1] + j * lonStep]);
            }
          }
          return candidates;
        },

        dedupeCandidates: (candidates, seen) => {
          const out = [];
          candidates.forEach(c => {
            if (!Utils.isValidCoord(c)) return;
            const key = Utils.coordKey(c);
            if (seen && seen.has(key)) return;
            if (seen) seen.add(key);
            out.push(c);
          });
          return out;
        },

        estimateRequests: (points, gridSize, settings) => {
          const base = gridSize * gridSize + 4;
          const topK = Math.min(settings?.refineTopK || 0, base);
          let localGrid = settings?.localGridSize || 0;
          if (localGrid % 2 === 0) localGrid += 1;
          const local = topK * localGrid * localGrid;
          const hill = (settings?.hillSteps || 0) * 8;
          return Math.max(0, Math.round((base + local + hill) * points.length));
        }
      };

      const Log = {
        append: (msg, data) => {
          const text = `[${Utils.now()}] ${msg}` + (data !== undefined ? '\n' + JSON.stringify(data, null, 2) : '');
          console.log('%c' + msg, 'color:#4d9fff;font-weight:bold', data ?? '');
          if (DOM.logArea) { DOM.logArea.value += (DOM.logArea.value ? '\n\n' : '') + text; DOM.logArea.scrollTop = DOM.logArea.scrollHeight; }
          State.history.push({ time: new Date().toISOString(), msg, data });
        },
        clear: () => { if (DOM.logArea) DOM.logArea.value = ''; Log.append('–õ–æ–≥ –æ—á–∏—â–µ–Ω'); }
      };

      const Cache = {
        storageKey: 'fmp_route_cache_' + CONSTANTS.CACHE_VERSION,
        maxEntries: 500,
        load: () => {
          try {
            const raw = localStorage.getItem(Cache.storageKey);
            if (!raw) return;
            const data = JSON.parse(raw);
            if (Array.isArray(data)) data.forEach(([k, v]) => State.routeCache.set(k, v));
            Cache.prune();
          } catch { }
        },
        persistSoon: () => {
          if (State.routeCacheDirty) return;
          State.routeCacheDirty = true;
          setTimeout(() => {
            if (!State.routeCacheDirty) return;
            try {
              const entries = Array.from(State.routeCache.entries());
              localStorage.setItem(Cache.storageKey, JSON.stringify(entries));
            } catch (e) {
              if (e?.name === 'QuotaExceededError') { Cache.maxEntries = Math.floor(Cache.maxEntries / 2); Cache.prune(); }
            }
            State.routeCacheDirty = false;
          }, 800);
        },
        prune: () => {
          while (State.routeCache.size > Cache.maxEntries) {
            const firstKey = State.routeCache.keys().next().value;
            if (!firstKey) break;
            State.routeCache.delete(firstKey);
          }
        },
        get: (key, nowMs, ttlMs) => {
          const entry = State.routeCache.get(key);
          if (!entry) return null;
          const ttl = entry.estimated ? Math.min(ttlMs, 2 * 60 * 1000) : ttlMs;
          if (nowMs - entry.t > ttl) { State.routeCache.delete(key); return null; }
          return entry;
        },
        set: (key, value) => {
          State.routeCache.set(key, value);
          Cache.prune();
          Cache.persistSoon();
        }
      };

      const UI = {
        toggleCard: id => $(id)?.classList.toggle('collapsed'),
        openModal: id => $(id)?.classList.add('show'),
        closeModal: id => $(id)?.classList.remove('show'),

        setTheme: theme => {
          State.theme = theme;
          document.documentElement.setAttribute('data-theme', theme);
          if (DOM.themeBtn) DOM.themeBtn.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
          try { localStorage.setItem('fmp_theme', theme); } catch { }
        },

        toggleTheme: () => UI.setTheme(State.theme === 'dark' ? 'light' : 'dark'),

        setTimeMode: mode => {
          State.timeMode = mode;
          if (DOM.btnTimeDeparture) DOM.btnTimeDeparture.classList.toggle('active', mode === 'departure');
          if (DOM.btnTimeArrival) DOM.btnTimeArrival.classList.toggle('active', mode === 'arrival');
        },

        setApiStatus: (type, text) => {
          if (DOM.apiStatus) { DOM.apiStatus.className = 'status ' + type; DOM.apiStatus.innerHTML = text; }
          if (DOM.apiBadge) {
            DOM.apiBadge.textContent = type === 'ok' ? 'online' : (type === 'bad' ? 'error' : 'offline');
            DOM.apiBadge.style.background = type === 'ok' ? 'var(--ok-soft)' : (type === 'bad' ? 'var(--bad-soft)' : 'var(--warn-soft)');
            DOM.apiBadge.style.borderColor = type === 'ok' ? 'var(--ok-border)' : (type === 'bad' ? 'var(--bad-border)' : 'var(--warn-border)');
            DOM.apiBadge.style.color = type === 'ok' ? 'var(--ok)' : (type === 'bad' ? 'var(--bad)' : 'var(--warn)');
          }
        },

        setFindStatus: (type, text) => { if (DOM.findStatus) { DOM.findStatus.className = 'status ' + type; DOM.findStatus.innerHTML = text; } },

        setProgress: (phase, current, total) => {
          if (!DOM.progressContainer) return;
          if (total <= 0) { DOM.progressContainer.style.display = 'none'; return; }
          DOM.progressContainer.style.display = 'block';
          const pct = Math.round((current / total) * 100);
          DOM.progressFill.style.width = pct + '%';
          DOM.progressPhase.textContent = phase;
          const eta = Utils.calcETA();
          DOM.progressPct.textContent = pct + '%' + (eta ? ` (~${eta}—Å)` : '');
        },

        updateLiveStats: () => {
          const s = State.currentSearch;
          if ($('statSent')) $('statSent').textContent = s.sent;
          if ($('statOk')) $('statOk').textContent = s.ok;
          if ($('statFail')) $('statFail').textContent = s.fail;
          if ($('statTotal')) $('statTotal').textContent = s.sent;
          if ($('statExpected')) $('statExpected').textContent = s.expected;
        },

        showLiveStats: show => {
          if ($('liveStats')) $('liveStats').style.display = show ? 'flex' : 'none';
        },

        updateStats: () => {
          const g = State.stats.geocode, r = State.stats.route;
          const totalRequests = g.total + r.total;
          if (DOM.chipTotal) DOM.chipTotal.textContent = totalRequests;
          if (DOM.chipOk) DOM.chipOk.textContent = g.ok + r.ok;
          if (DOM.chipFail) DOM.chipFail.textContent = g.fail + r.fail + r.timeout;
          if ($('chipGeo')) $('chipGeo').textContent = g.total;
          if ($('chipRoute')) $('chipRoute').textContent = r.total;
          if ($('chipTimeout')) $('chipTimeout').textContent = r.timeout;
          try { localStorage.setItem('fmp_stats', JSON.stringify(State.stats)); } catch { }
        },

        updatePointsList: () => {
          const enabledCount = State.points.filter(p => p.enabled !== false).length;
          if (DOM.pointsBadge) DOM.pointsBadge.textContent = `${enabledCount}/${State.points.length}`;

          if (State.points.length === 0) {
            if (DOM.pointsList) DOM.pointsList.innerHTML = '<div class="empty-state">–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å</div>';
            return;
          }

          if (DOM.pointsList) {
            DOM.pointsList.innerHTML = State.points.map(p => {
              const dis = p.enabled === false;
              const retLabel = p.returnAddress ? `‚Ü©Ô∏è ${Utils.escHtml(p.returnAddress)}` : '';
              return `
            <div class="point-item${dis ? ' disabled' : ''}" data-id="${p.id}">
              <input type="checkbox" class="point-toggle" data-id="${p.id}" ${dis ? '' : 'checked'} title="–í–∫–ª/–≤—ã–∫–ª —É—á–∞—Å—Ç–Ω–∏–∫–∞">
              <div class="point-dot" style="background:${p.color}"></div>
              <div class="point-info">
                <div class="point-name">
                  <input type="text" value="${Utils.escAttr(p.name)}" data-id="${p.id}" class="point-name-input">
                  <span class="point-transport ${p.transport}">${p.transport === 'auto' ? 'üöó' : 'üöá'}</span>
                </div>
                <div class="point-coords">${Utils.fmtCoord(p.coords)}</div>
                <div class="point-return">
                  <button class="btn-return" onclick="App.setReturnPoint('${p.id}')" title="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ç–æ—á–∫—É –≤–æ–∑–≤—Ä–∞—Ç–∞">‚Ü©Ô∏è –æ–±—Ä–∞—Ç–Ω–æ</button>
                  ${retLabel ? `<span class="return-addr">${retLabel}</span><button class="btn-return" onclick="App.clearReturnPoint('${p.id}')">‚úï</button>` : '<span class="return-addr" style="color:var(--muted)">–≤ –∏—Å—Ö–æ–¥–Ω—É—é</span>'}
                </div>
              </div>
              <div class="point-actions">
                <button class="btn-ghost btn-sm" onclick="App.toggleTransport('${p.id}')" title="–°–º–µ–Ω–∏—Ç—å —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç">üîÑ</button>
                <button class="btn-bad btn-sm" onclick="App.removePoint('${p.id}')">‚úï</button>
              </div>
            </div>
          `;
            }).join('');

            DOM.pointsList.querySelectorAll('.point-name-input').forEach(inp => {
              inp.addEventListener('change', e => App.renamePoint(e.target.dataset.id, e.target.value));
            });
            DOM.pointsList.querySelectorAll('.point-toggle').forEach(cb => {
              cb.addEventListener('change', e => App.toggleEnabled(e.target.dataset.id, e.target.checked));
            });
          }

          UI.updateEstimates();
          UI.updateFindButton();
        },

        updateEstimates: () => {
          const activePts = State.points.filter(p => p.enabled !== false);
          if (activePts.length < 2) {
            if (DOM.estRequests) DOM.estRequests.textContent = '‚Äî';
            if (DOM.estCost) DOM.estCost.textContent = '‚Äî';
            return;
          }
          const gridSize = Utils.clamp(DOM.gridSize?.value, 3, 12, 6);
          let est = Math2.estimateRequests(activePts, gridSize, State.settings);
          if (State.returnTrip) est = Math.round(est * 2);
          const estStr = State.returnTrip ? `~${est} (üîÑ —Ç—É–¥–∞-–æ–±—Ä–∞—Ç–Ω–æ)` : `~${est}`;
          if (DOM.estRequests) DOM.estRequests.textContent = estStr;
          if (DOM.estCost) {
            const costPaid = (est * 0.16).toFixed(0);
            DOM.estCost.textContent = `–±–µ—Å–ø–ª–∞—Ç–Ω–æ / ~${costPaid}‚ÇΩ`;
          }

          // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–≤—å—é —Å–µ—Ç–∫–∏ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
          if (State.showingGrid) App.showGridPreview();
        },

        updateFindButton: () => {
          const enabledPts = State.points.filter(p => p.enabled !== false);
          const canFind = State.apiLoaded && enabledPts.length >= 2 && !State.running;
          if (DOM.btnFind) DOM.btnFind.disabled = !canFind;

          if (enabledPts.length >= 2 && !State.running && State.results.length === 0) {
            UI.setFindStatus('info', '‚úÖ –ì–æ—Ç–æ–≤–æ. –ù–∞–∂–º–∏—Ç–µ "–ù–∞–π—Ç–∏ —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏"');
          } else if (enabledPts.length < 2) {
            UI.setFindStatus('info', `–í–∫–ª—é—á–∏—Ç–µ –º–∏–Ω–∏–º—É–º 2 —É—á–∞—Å—Ç–Ω–∏–∫–∞ (—Å–µ–π—á–∞—Å ${enabledPts.length})`);
          }
        },

        showResults: (results, selectedIndex = 0) => {
          State.results = results;
          State.selectedResultIndex = selectedIndex;

          if (results.length === 0) return;

          App.showAllResultMarkers(results);
          UI.showSelectedResult(selectedIndex);
        },

        showSelectedResult: (index) => {
          if (index < 0 || index >= State.results.length) return;
          State.selectedResultIndex = index;

          const result = State.results[index];
          if (DOM.resultsBadge) DOM.resultsBadge.textContent = Utils.secToStr(result.mean);

          State.resultMarkers.forEach((m, i) => {
            if (m && m.options) {
              try { m.options.set('preset', i === index ? 'islands#redStarIcon' : 'islands#grayCircleDotIcon'); } catch { }
            }
          });

          const coordsStr = Utils.fmtCoord(result.coords);
          const timesHtml = result.routes.map(r => {
            const walkExtra = r.walkAfterTransport > 60 ? `<span class="walk-extra">+${Utils.secToStrShort(r.walkAfterTransport)} üö∂</span>` : '';
            const estPrefix = r.estimated ? '‚âà ' : '';
            const returnInfo = r.returnDuration > 0 ? `<span style="color:var(--muted);font-size:9px"> ‚Ü©Ô∏è ${Utils.secToStr(r.returnDuration)}</span>` : '';
            return `
            <div class="route-time-item">
              <div class="dot" style="background:${r.color}"></div>
              <div class="name">${Utils.escHtml(r.name)}</div>
              <div class="time">${estPrefix}${Utils.secToStr(r.duration)} ${walkExtra}${returnInfo}</div>
            </div>
          `;
          }).join('');

          const metricTag = result.metricName ? `<span class="metric-tag">${METRIC_NAMES[result.metricName] || result.metricName}</span>` : '';
          const walkTag = result.maxWalk < 180 ? '<span class="walk-tag">üöá –£ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞</span>' : '';

          const hasMore = State.allResults.length > State.displayCount;

          if (DOM.resultsContent) {
            DOM.resultsContent.innerHTML = `
            <div class="result-summary">
              <h3>‚≠ê #${index + 1} ${result.poiName ? `<span style="color:var(--warn)">üè¢ ${Utils.escHtml(result.poiName)}</span>` : '–¢–æ—á–∫–∞ –≤—Å—Ç—Ä–µ—á–∏'} ${metricTag} ${walkTag}</h3>
              ${result.poiAddress ? `<div style="font-size:10px;color:var(--muted);margin:-2px 0 4px">üì´ ${Utils.escHtml(result.poiAddress)}</div>` : ''}
              <div class="coords-row">
                <code>${coordsStr}</code>
                <button class="copy-btn btn-ghost" onclick="App.copyCoords('${coordsStr}')">üìã</button>
              </div>
              <div class="result-metrics">
                <div class="metric-box"><div class="val">${Utils.secToStr(result.mean)}</div><div class="label">–°—Ä–µ–¥–Ω–µ–µ</div></div>
                <div class="metric-box"><div class="val">${Utils.secToStr(result.range)}</div><div class="label">–†–∞–∑–Ω–∏—Ü–∞</div></div>
                <div class="metric-box"><div class="val">${Utils.secToStr(result.min)}</div><div class="label">–ú–∏–Ω</div></div>
                <div class="metric-box"><div class="val">${Utils.secToStr(result.max)}</div><div class="label">–ú–∞–∫—Å</div></div>
              </div>
              <div class="route-times">${timesHtml}</div>
            </div>
            <div style="font-size:10px;font-weight:600;margin:8px 0 4px;color:var(--muted);">üèÜ –¢–û–ü-${State.displayCount} –∏–∑ ${State.allResults.length} —Ç–æ—á–µ–∫:</div>
            <div class="top-results">
              ${State.results.map((r, i) => {
              const rankClass = i === 0 ? 'gold' : (i === 1 ? 'silver' : (i === 2 ? 'bronze' : ''));
              const activeClass = i === index ? 'active' : '';
              const times = r.routes.map(rt => `${rt.estimated ? '‚âà ' : ''}${Utils.secToStr(rt.duration)}`).join(' / ');
              const mTag = r.metricName ? `<span class="metric-tag">${METRIC_NAMES[r.metricName] || ''}</span>` : '';
              const wTag = r.maxWalk < 180 ? '<span class="walk-tag">üöá</span>' : '';
              return `
                  <div class="top-result-item ${activeClass}" onclick="App.selectResult(${i})">
                    <div class="rank ${rankClass}">#${i + 1}</div>
                    <div class="info">
                      <div>–°—Ä–µ–¥–Ω–µ–µ: <strong>${Utils.secToStr(r.mean)}</strong>, —Ä–∞–∑–Ω–∏—Ü–∞: ${Utils.secToStr(r.range)} ${mTag} ${wTag}</div>
                      ${r.poiName ? `<div style="font-size:9px;color:var(--warn)">üè¢ ${Utils.escHtml(r.poiName)}</div>` : ''}
                      <div class="times">${times}</div>
                    </div>
                    <div class="score">${r.score.toFixed(0)}</div>
                  </div>
                `;
            }).join('')}
            </div>
            ${hasMore ? `<button class="btn-ghost load-more-btn" onclick="App.loadMore()">üìã –ü–æ–∫–∞–∑–∞—Ç—å –µ—â—ë ${Math.min(5, State.allResults.length - State.displayCount)} –∏–∑ ${State.allResults.length - State.displayCount}</button>` : ''}
          `;
          }

          UI.showRoutes(result.routes);
        },

        showUltraResults: ultraResults => {
          State.ultraResults = ultraResults;
          const container = $('ultraCompareContainer');
          if (!container) return;

          container.style.display = 'block';

          const metrics = ['minimax', 'range', 'composite', 'nearmetro', 'maxdev', 'variance'];

          let html = `
          <div style="font-size:10px;font-weight:600;margin:8px 0 4px;color:var(--muted);">üî¨ ULTRA: –õ—É—á—à–∞—è —Ç–æ—á–∫–∞ –ø–æ –∫–∞–∂–¥–æ–π –º–µ—Ç—Ä–∏–∫–µ</div>
          <table class="ultra-table">
            <thead><tr><th>–ú–µ—Ç—Ä–∏–∫–∞</th><th>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã</th><th>–°—Ä–µ–¥–Ω–µ–µ</th><th>Max</th><th>–†–∞–∑–Ω–∏—Ü–∞</th><th>–í—Ä–µ–º–µ–Ω–∞</th></tr></thead>
            <tbody>
        `;

          const bestMean = Math.min(...metrics.map(m => ultraResults[m]?.mean || Infinity));
          const bestMax = Math.min(...metrics.map(m => ultraResults[m]?.max || Infinity));
          const bestRange = Math.min(...metrics.map(m => ultraResults[m]?.range || Infinity));

          for (const m of metrics) {
            const r = ultraResults[m];
            if (!r) continue;
            const isBest = r.mean === bestMean || r.max === bestMax || r.range === bestRange;
            const times = r.routes.map(rt => `${rt.estimated ? '‚âà ' : ''}${Utils.secToStrShort(rt.duration)}`).join(', ');
            html += `
            <tr class="${isBest ? 'best' : ''}">
              <td><strong>${METRIC_NAMES[m]}</strong></td>
              <td class="coords-cell">${Utils.fmtCoordShort(r.coords)}</td>
              <td class="num ${r.mean === bestMean ? 'winner' : ''}">${Utils.secToStr(r.mean)}</td>
              <td class="num ${r.max === bestMax ? 'winner' : ''}">${Utils.secToStr(r.max)}</td>
              <td class="num ${r.range === bestRange ? 'winner' : ''}">${Utils.secToStr(r.range)}</td>
              <td style="font-size:8px;">${times}</td>
            </tr>
          `;
          }

          html += '</tbody></table>';
          container.innerHTML = html;
        },

        showRoutes: routes => {
          if (!DOM.routesPanel) return;
          DOM.routesPanel.style.display = 'block';
          DOM.routesPanel.innerHTML = routes.map(r => {
            const icons = { walk: 'üö∂', bus: 'üöå', trolleybus: 'üöé', tram: 'üöä', metro: 'üöá', suburban: 'üöÜ', transfer: 'üîÑ', auto: 'üöó' };
            const segsHtml = r.segments.map(s =>
              `<span class="segment ${s.type}"><span>${icons[s.type] || '‚Ä¢'}</span> ${Utils.escHtml(s.name.split('\n')[0].slice(0, 18))}</span>`
            ).join('');

            const walkExtra = r.walkAfterTransport > 60 ? `<span style="color:var(--warn);font-size:9px;margin-left:4px;">+${Utils.secToStrShort(r.walkAfterTransport)} üö∂</span>` : '';

            return `
            <div class="route-card">
              <div class="route-header">
                <div class="name"><span style="display:inline-block;width:6px;height:6px;border-radius:50%;background:${r.color}"></span> ${Utils.escHtml(r.name)}</div>
                <div class="time">${r.estimated ? '‚âà ' : ''}${Utils.secToStr(r.duration)} ${walkExtra}</div>
              </div>
              <div class="route-segments">${segsHtml || '<span style="color:var(--muted);font-size:8px;">–ù–µ—Ç –¥–µ—Ç–∞–ª–µ–π</span>'}</div>
            </div>
          `;
          }).join('');
        },

        enableControls: enabled => {
          const els = ['inputAddr', 'inputName', 'inputTransport', 'btnAddPoint', 'btnMyLocation', 'btnClearPoints', 'btnFitAll', 'gridSize', 'gridExpandH', 'gridExpandV', 'timeout', 'departureTime', 'btnNow', 'btnTimeUp', 'btnTimeDown', 'btnTimeDeparture', 'btnTimeArrival', 'btnShowGrid', 'poiQuery', 'btnSearchPOI', 'poiExpandH', 'poiExpandV', 'poiMaxResults'];
          els.forEach(id => { if (DOM[id]) DOM[id].disabled = !enabled; });
          UI.updateFindButton();
          App.updateHeatmapButton();
        }
      };

      const API = {
        loadYandex: key => {
          if (!key?.trim()) { UI.setApiStatus('bad', '‚ùå –í–≤–µ–¥–∏—Ç–µ API –∫–ª—é—á'); return; }
          if (window.ymaps) { UI.setApiStatus('warn', '‚ö†Ô∏è API —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω'); return; }

          try { localStorage.setItem('fmp_apikey', key); } catch { }
          UI.setApiStatus('warn', '‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ API...');
          Log.append('–ó–∞–≥—Ä—É–∑–∫–∞ Yandex Maps JS API');

          const script = document.createElement('script');
          script.src = `https://api-maps.yandex.ru/2.1/?apikey=${encodeURIComponent(key)}&lang=ru_RU`;
          script.async = true;

          script.onload = () => {
            if (!window.ymaps) { UI.setApiStatus('bad', '‚ùå ymaps –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'); return; }
            ymaps.ready(() => {
              State.apiLoaded = true;
              UI.setApiStatus('ok', '‚úÖ API –≥–æ—Ç–æ–≤');
              Log.append('ymaps.ready()');
              API.initMap();
              UI.enableControls(true);

              setTimeout(() => {
                try {
                  const saved = localStorage.getItem('fmp_points');
                  if (saved) JSON.parse(saved).forEach(p => App.addPoint(p.coords, p, true));
                } catch { }
              }, 300);
            });
          };

          script.onerror = () => { UI.setApiStatus('bad', '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏'); };
          document.head.appendChild(script);
        },

        initMap: () => {
          State.map = new ymaps.Map('map', {
            center: [55.751244, 37.618423], zoom: 11,
            controls: ['zoomControl', 'typeSelector', 'fullscreenControl', 'rulerControl']
          }, { suppressMapOpenBlock: true });

          State.map.events.add('click', async e => {
            if (!State.apiLoaded) return;
            if (State.results.length > 0) {
              const ok = await Utils.customConfirm('‚ö†Ô∏è –°–±—Ä–æ—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤', '–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Ç–æ—á–∫–∏ —Å–±—Ä–æ—Å–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?');
              if (!ok) return;
            }
            const coords = e.get('coords');
            const name = DOM.inputName?.value.trim() || `–¢–æ—á–∫–∞ ${State.points.length + 1}`;
            const transport = DOM.inputTransport?.value || 'masstransit';
            App.addPoint(coords, { name, transport });
            if (DOM.inputName) DOM.inputName.value = '';
          });

          Log.append('–ö–∞—Ä—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
        },

        geocode: async query => {
          State.stats.geocode.total++;
          State.currentSearch.sent++;
          UI.updateStats();
          UI.updateLiveStats();

          try {
            const res = await ymaps.geocode(query);
            const first = res.geoObjects.get(0);
            if (!first) {
              State.stats.geocode.fail++;
              State.currentSearch.fail++;
              UI.updateStats();
              UI.updateLiveStats();
              return { ok: false, error: '–ù–µ –Ω–∞–π–¥–µ–Ω–æ' };
            }

            const coords = first.geometry.getCoordinates();
            const address = first.getAddressLine?.() || first.properties.get('text');
            State.stats.geocode.ok++;
            State.currentSearch.ok++;
            UI.updateStats();
            UI.updateLiveStats();
            return { ok: true, coords, address };
          } catch (e) {
            State.stats.geocode.fail++;
            State.currentSearch.fail++;
            UI.updateStats();
            UI.updateLiveStats();
            return { ok: false, error: String(e) };
          }
        },

        calcRoute: (from, to, transport, timeoutMs, runId, timeContext) => {
          State.currentSearch.sent++;
          UI.updateLiveStats();

          const when = timeContext || Utils.getSearchTime();
          const bucketMinutes = Utils.isPeakHour(when) ? 5 : 10;
          const bucket = Utils.timeBucket(when, bucketMinutes);
          const key = `${Utils.coordKey(from)}>${Utils.coordKey(to)}|${transport}|${bucket}|${State.timeMode}`;
          const ttl = Utils.getCacheTtlMs(when);
          const nowMs = Date.now();
          const cached = Cache.get(key, nowMs, ttl);

          if (cached) {
            State.currentSearch.ok++;
            State.currentSearch.cached = (State.currentSearch.cached || 0) + 1;
            UI.updateLiveStats();
            return Promise.resolve({
              ok: true,
              durationSec: cached.durationSec,
              durationText: cached.durationText,
              segments: cached.segments || [],
              estimated: cached.estimated,
              fromCache: true
            });
          }

          const exec = () => new Promise(resolve => {
            let done = false;
            const routingMode = transport === 'auto' ? 'auto' : 'masstransit';

            State.stats.route.total++;
            UI.updateStats();

            const mr = new ymaps.multiRouter.MultiRoute({
              referencePoints: [from, to],
              params: { routingMode }
            }, { boundsAutoApply: false });

            const model = mr.model;

            const finish = result => {
              if (done) return;
              done = true;
              try { model.events.remove('requestsuccess', onSuccess); model.events.remove('requestfail', onFail); } catch { }
              try { mr.destroy(); } catch { }
              resolve(result);
            };

            const onSuccess = () => {
              if (runId !== State.runId || State.cancelled) { finish({ ok: false, error: 'cancelled' }); return; }

              const active = mr.getActiveRoute();
              if (!active) { finish({ ok: false, error: 'no_active_route' }); return; }

              const duration = active.properties.get('duration');
              if (!duration?.value) { finish({ ok: false, error: 'no_duration' }); return; }

              const segments = [];
              try {
                active.getPaths().each(path => {
                  path.getSegments().each(seg => {
                    const props = seg.properties.getAll();
                    const dur = props.duration?.value;
                    if (!dur || dur < 30) return;

                    let type = 'walk', name = props.text || '';
                    if (props.type === 'masstransit') {
                      const t = props.transports?.[0];
                      if (t) {
                        name = t.name || t.title || name;
                        const tt = t.type;
                        if (tt === 'bus' || tt === 'minibus') type = 'bus';
                        else if (tt === 'trolleybus') type = 'trolleybus';
                        else if (tt === 'tram') type = 'tram';
                        else if (tt === 'underground' || tt === 'metro') type = 'metro';
                        else if (tt === 'suburban') type = 'suburban';
                        else type = 'bus';
                      }
                    } else if (props.type === 'transfer') { type = 'transfer'; name = '–ü–µ—Ä–µ—Å–∞–¥–∫–∞'; }
                    else if (routingMode === 'auto') { type = 'auto'; name = '–ù–∞ –∞–≤—Ç–æ'; }

                    segments.push({ type, name, duration: dur });
                  });
                });
              } catch { }

              State.stats.route.ok++;
              State.currentSearch.ok++;
              UI.updateStats();
              UI.updateLiveStats();

              finish({ ok: true, durationSec: duration.value, durationText: duration.text, segments, multiRoute: mr });
            };

            const onFail = e => finish({ ok: false, error: String(e?.get?.('error')) || 'requestfail' });

            model.events.add('requestsuccess', onSuccess);
            model.events.add('requestfail', onFail);

            setTimeout(() => {
              if (done) return;
              State.stats.route.timeout++;
              UI.updateStats();
              finish({ ok: false, error: 'timeout' });
            }, timeoutMs);
          });

          const runner = State.routeLimiter ? State.routeLimiter(exec) : exec();
          return runner.then(result => {
            if (result.ok) {
              Cache.set(key, {
                t: Date.now(),
                durationSec: result.durationSec,
                durationText: result.durationText,
                segments: result.segments || [],
                estimated: result.estimated
              });
              return result;
            }

            if (result.error !== 'timeout' && result.error !== 'cancelled') State.stats.route.fail++;
            UI.updateStats();
            if (runId !== State.runId || State.cancelled) return result;

            // Retry once before fallback
            const retryExec = () => new Promise(resolve => setTimeout(() => {
              API.calcRoute(from, to, transport, timeoutMs, runId, timeContext).then(resolve);
            }, CONSTANTS.RETRY_DELAY_MS));

            // On failure, fallback to estimate
            State.currentSearch.fail++;
            UI.updateLiveStats();

            const est = Utils.estimateDurationSec(from, to, transport, when);
            State.currentSearch.estimated = (State.currentSearch.estimated || 0) + 1;
            UI.updateLiveStats();
            const estimate = { ok: true, estimated: true, durationSec: est, durationText: Utils.secToStr(est), segments: [] };
            Cache.set(key, { t: Date.now(), durationSec: estimate.durationSec, durationText: estimate.durationText, segments: [], estimated: true });
            return estimate;
          });
        },

        searchPOI: async (query, bbox, maxResults = 20, skip = 0) => {
          if (!query?.trim()) return { places: [], total: 0 };
          try {
            const res = await ymaps.search(query, {
              boundedBy: [[bbox.minLat, bbox.minLon], [bbox.maxLat, bbox.maxLon]],
              strictBounds: true,
              results: maxResults,
              skip: skip
            });
            const total = res.properties?.get('metaDataProperty.SearchResponse.found') || 0;
            const places = [];
            res.geoObjects.each(obj => {
              const coords = obj.geometry.getCoordinates();
              const props = obj.properties.getAll();
              const name = props.name || props.text || query;
              const desc = props.description || '';
              const meta = props.metaDataProperty?.GeocoderMetaData;
              places.push({
                name,
                coords,
                address: desc || meta?.text || '',
                category: query,
                balloonContent: props.balloonContent || '',
                id: Utils.uuid()
              });
            });
            Log.append(`POI: "${query}" ‚Äî ${places.length} –∑–∞–≥—Ä—É–∂–µ–Ω–æ, –≤—Å–µ–≥–æ ${total}`, { bbox, skip, maxResults });
            return { places, total: parseInt(total, 10) || places.length };
          } catch (e) {
            Log.append(`POI –æ—à–∏–±–∫–∞: ${e.message}`);
            return { places: [], total: 0 };
          }
        }
      };

      const Algorithm = {
        scoreForMetric: (result, metricKey) => result?.scores?.[metricKey] ?? Number.POSITIVE_INFINITY,

        bestByMetric: (results, metricKey) => {
          if (!results.length) return null;
          return results.reduce((best, r) => Algorithm.scoreForMetric(r, metricKey) < Algorithm.scoreForMetric(best, metricKey) ? r : best, results[0]);
        },

        evaluateCandidate: async (cand, origins, transports, timeoutMs, runId, timeContext, progress, phaseLabel) => {
          const tasks = origins.map((origin, i) =>
            API.calcRoute(origin, cand, transports[i], timeoutMs, runId, timeContext).then(r => {
              progress.count++;
              UI.setProgress(phaseLabel, progress.count, progress.total);
              return r;
            })
          );

          const results = await Promise.all(tasks);
          if (runId !== State.runId || State.cancelled) return null;
          if (results.some(r => !r.ok)) return null;

          const durations = [];
          const routes = [];
          let estimatedCount = 0;

          const activePoints = State.points.filter(p => p.enabled !== false);
          results.forEach((r, i) => {
            durations.push(r.durationSec);
            if (r.estimated) estimatedCount++;
            routes.push({
              pointId: activePoints[i]?.id,
              name: activePoints[i]?.name || `–¢–æ—á–∫–∞ ${i + 1}`,
              color: activePoints[i]?.color || '#888',
              transport: transports[i],
              duration: r.durationSec,
              durationText: r.durationText,
              segments: r.segments || [],
              estimated: !!r.estimated,
              returnDuration: 0
            });
          });

          // –û–±—Ä–∞—Ç–Ω—ã–π –ø—É—Ç—å
          if (State.returnTrip) {
            const returnDests = origins.map((origin, i) => activePoints[i]?.returnCoords || origin);
            const returnTasks = returnDests.map((dest, i) =>
              API.calcRoute(cand, dest, transports[i], timeoutMs, runId, timeContext).then(r => {
                progress.count++;
                UI.setProgress(phaseLabel, progress.count, progress.total);
                return r;
              })
            );
            const returnResults = await Promise.all(returnTasks);
            if (runId !== State.runId || State.cancelled) return null;

            returnResults.forEach((rr, i) => {
              if (rr.ok) {
                routes[i].returnDuration = rr.durationSec;
                durations[i] += rr.durationSec;
                if (rr.estimated) estimatedCount++;
              } else {
                // –ï—Å–ª–∏ –æ–±—Ä–∞—Ç–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç –Ω–µ –ø–æ—Å—Ç—Ä–æ–∏–ª—Å—è ‚Äî –∑–µ—Ä–∫–∞–ª–∏–º –ø—Ä—è–º–æ–π
                routes[i].returnDuration = routes[i].duration;
                durations[i] += routes[i].duration;
              }
            });
          }

          const metrics = Math2.calcMetrics(durations);
          const walkInfo = Math2.calcWalkAfterTransport(routes);
          const penalty = estimatedCount * CONSTANTS.ESTIMATED_PENALTY;
          const w = State.compositeWeights;

          return {
            coords: cand,
            durations,
            routes,
            estimatedCount,
            ...metrics,
            ...walkInfo,
            scores: {
              minimax: metrics.max + penalty,
              range: metrics.range + penalty,
              composite: metrics.max * w.alpha + metrics.std * w.beta + metrics.range * w.gamma + penalty,
              nearmetro: metrics.max * w.alpha + metrics.std * w.beta + metrics.range * w.gamma + walkInfo.totalWalk * 0.5 + walkInfo.maxWalk * 2 + penalty,
              maxdev: metrics.maxDev + penalty,
              variance: metrics.variance + penalty
            }
          };
        },

        evaluateCandidates: async (candidates, origins, transports, timeoutMs, runId, timeContext, progress, phaseLabel) => {
          const results = [];
          const batchSize = CONSTANTS.BATCH_SIZE;
          for (let ci = 0; ci < candidates.length; ci += batchSize) {
            if (runId !== State.runId || State.cancelled) break;
            const batch = candidates.slice(ci, ci + batchSize);
            const batchResults = await Promise.all(batch.map((c, bi) => {
              const idx = ci + bi + 1;
              const label = `${phaseLabel} ${idx}/${candidates.length}`;
              return Algorithm.evaluateCandidate(c, origins, transports, timeoutMs, runId, timeContext, progress, label);
            }));
            batchResults.forEach(res => { if (res) results.push(res); });
            UI.setFindStatus('warn', `üîç ${phaseLabel}: ${Math.min(ci + batchSize, candidates.length)}/${candidates.length}, –Ω–∞–π–¥–µ–Ω–æ ${results.length} —Ç–æ—á–µ–∫`);
          }
          return results;
        },

        generateNeighbors: (center, stepM) => {
          const dLat = Utils.metersToLat(stepM);
          const dLon = Utils.metersToLon(stepM, center[0]);
          return [
            [center[0] + dLat, center[1]],
            [center[0] - dLat, center[1]],
            [center[0], center[1] + dLon],
            [center[0], center[1] - dLon],
            [center[0] + dLat, center[1] + dLon],
            [center[0] + dLat, center[1] - dLon],
            [center[0] - dLat, center[1] + dLon],
            [center[0] - dLat, center[1] - dLon]
          ];
        },

        find: async () => {
          const activePoints = State.points.filter(p => p.enabled !== false);
          if (!State.apiLoaded || activePoints.length < 2) return;

          State.running = true;
          State.cancelled = false;
          const runId = ++State.runId;

          const metricName = Utils.getSelectedMetric();
          const isUltra = metricName === 'ultra';
          const metricKey = isUltra ? 'composite' : metricName;
          const gridSize = Utils.clamp(DOM.gridSize?.value, 3, 12, 6);
          const expandH = Utils.clamp(DOM.gridExpandH?.value, 0, 100, 20);
          const expandV = Utils.clamp(DOM.gridExpandV?.value, 0, 100, 20);
          const timeoutMs = Utils.clamp(DOM.timeout?.value, 5, 60, 25) * 1000;
          const timeContext = Utils.getSearchTime();

          const estimatedRoutes = Math2.estimateRequests(activePoints, gridSize, State.settings);

          State.currentSearch = { sent: 0, ok: 0, fail: 0, expected: estimatedRoutes, cached: 0, estimated: 0, startTime: Date.now() };
          State.displayCount = 5;
          UI.showLiveStats(true);
          UI.updateLiveStats();

          Log.append('–ü–æ–∏—Å–∫: —Å—Ç–∞—Ä—Ç', { metric: metricName, gridSize, timeMode: State.timeMode, expected: estimatedRoutes, time: timeContext.toISOString() });

          if (DOM.btnFind) DOM.btnFind.disabled = true;
          if (DOM.btnCancel) DOM.btnCancel.disabled = false;
          App.clearResult();
          App.hideGridPreview();

          const origins = activePoints.map(p => p.coords);
          const transports = activePoints.map(p => p.transport);
          State.routeLimiter = Utils.createLimiter(Math.max(1, Math.min(State.settings.maxConcurrentRoutes, origins.length)));
          const bbox = Math2.bbox(activePoints, expandH, expandV);
          const baseGrid = Math2.generateGrid(activePoints, gridSize, expandH, expandV);
          const weighted = Math2.weightedCentroid(activePoints);
          const median = Math2.geometricMedian(activePoints);
          const bboxCenter = [(bbox.minLat + bbox.maxLat) / 2, (bbox.minLon + bbox.maxLon) / 2];

          const seen = new Set();
          const baseCandidates = Math2.dedupeCandidates([...baseGrid, weighted, median, bboxCenter], seen);
          const progress = { count: 0, total: baseCandidates.length * origins.length };
          State.currentSearch.expected = progress.total;
          UI.updateLiveStats();
          const allResults = [];

          const coarseResults = await Algorithm.evaluateCandidates(baseCandidates, origins, transports, timeoutMs, runId, timeContext, progress, '–ì—Ä—É–±–∞—è —Å–µ—Ç–∫–∞');
          allResults.push(...coarseResults);

          if (runId === State.runId && !State.cancelled && coarseResults.length > 0) {
            const sortedCoarse = [...coarseResults].sort((a, b) => Algorithm.scoreForMetric(a, metricKey) - Algorithm.scoreForMetric(b, metricKey));
            const topCount = Math.min(State.settings.refineTopK, sortedCoarse.length);

            if (topCount > 0) {
              const { latStep, lonStep } = Math2.gridStep(bbox, gridSize);
              const localLat = latStep / 2;
              const localLon = lonStep / 2;
              const localCandidates = [];
              sortedCoarse.slice(0, topCount).forEach(r => {
                localCandidates.push(...Math2.generateLocalGrid(r.coords, localLat, localLon, State.settings.localGridSize));
              });
              const refined = Math2.dedupeCandidates(localCandidates, seen);
              progress.total += refined.length * origins.length;
              State.currentSearch.expected = progress.total;
              UI.updateLiveStats();
              const refinedResults = await Algorithm.evaluateCandidates(refined, origins, transports, timeoutMs, runId, timeContext, progress, '–£—Ç–æ—á–Ω–µ–Ω–∏–µ');
              allResults.push(...refinedResults);
            }
          }

          if (runId === State.runId && !State.cancelled) {
            const best = Algorithm.bestByMetric(allResults, metricKey);
            if (best) {
              const { latStep, lonStep } = Math2.gridStep(bbox, gridSize);
              const latM = Utils.haversineM([bbox.minLat, bbox.minLon], [bbox.minLat + latStep, bbox.minLon]);
              const lonM = Utils.haversineM([bbox.minLat, bbox.minLon], [bbox.minLat, bbox.minLon + lonStep]);
              let stepM = Math.max(Math.max(latM, lonM) / 2, State.settings.hillMinStepM);
              let currentBest = best;

              for (let hi = 0; hi < State.settings.hillSteps; hi++) {
                if (runId !== State.runId || State.cancelled) break;
                const neighbors = Algorithm.generateNeighbors(currentBest.coords, stepM);
                const unique = Math2.dedupeCandidates(neighbors, seen);
                if (unique.length === 0) { stepM *= 0.5; if (stepM < State.settings.hillMinStepM) break; continue; }

                const label = `–õ–æ–∫–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ ${hi + 1}/${State.settings.hillSteps}`;
                progress.total += unique.length * origins.length;
                State.currentSearch.expected = progress.total;
                UI.updateLiveStats();
                const neighborResults = await Algorithm.evaluateCandidates(unique, origins, transports, timeoutMs, runId, timeContext, progress, label);
                allResults.push(...neighborResults);

                const bestNeighbor = Algorithm.bestByMetric([currentBest, ...neighborResults], metricKey);
                if (Algorithm.scoreForMetric(bestNeighbor, metricKey) + 1 < Algorithm.scoreForMetric(currentBest, metricKey)) {
                  currentBest = bestNeighbor;
                } else {
                  stepM *= 0.5;
                  if (stepM < State.settings.hillMinStepM) break;
                }
              }
            }
          }

          Algorithm.finish(allResults, metricName, isUltra, runId, gridSize);
        },

        finish: (allResults, metricName, isUltra, runId, gridSize) => {
          State.running = false;
          if (DOM.btnFind) DOM.btnFind.disabled = false;
          if (DOM.btnCancel) DOM.btnCancel.disabled = true;
          UI.setProgress('', 0, 0);

          if (State.cancelled) {
            UI.setFindStatus('warn', '‚õî –ü–æ–∏—Å–∫ –æ—Ç–º–µ–Ω—ë–Ω');
            UI.showLiveStats(false);
            UI.updateFindButton();
            return;
          }

          if (allResults.length === 0) {
            UI.setFindStatus('bad', '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–æ—á–∫—É');
            UI.showLiveStats(false);
            UI.updateFindButton();
            return;
          }

          const sortMetric = isUltra ? 'composite' : (metricName || 'minimax');
          const sorted = [...allResults].sort((a, b) => a.scores[sortMetric] - b.scores[sortMetric]);

          sorted.forEach(r => { r.score = r.scores[sortMetric]; r.metricName = sortMetric; });

          State.allResults = sorted;

          App.saveHeatmapData(sorted, sortMetric, gridSize);

          UI.showResults(sorted.slice(0, State.displayCount));

          if (isUltra) {
            const ultraResults = {};
            const metrics = ['minimax', 'range', 'composite', 'nearmetro', 'maxdev', 'variance'];
            for (const m of metrics) {
              const sortedByM = [...allResults].sort((a, b) => a.scores[m] - b.scores[m]);
              if (sortedByM.length > 0) {
                const best = { ...sortedByM[0] };
                best.metricName = m;
                ultraResults[m] = best;
              }
            }
            UI.showUltraResults(ultraResults);
          }

          const s = State.currentSearch;
          UI.setFindStatus('ok', `‚úÖ –ù–∞–π–¥–µ–Ω–æ ${allResults.length} —Ç–æ—á–µ–∫. –ú–∞—Ä—à—Ä—É—Ç–æ–≤: ${s.sent} (‚úì${s.ok} ‚úó${s.fail}, –∫–µ—à ${s.cached || 0}, –æ—Ü–µ–Ω–æ–∫ ${s.estimated || 0})`);

          Log.append('–ü–æ–∏—Å–∫: –∑–∞–≤–µ—Ä—à—ë–Ω', { totalFound: allResults.length, requests: s });
        },

        cancel: () => { State.cancelled = true; if (DOM.findStatus) DOM.findStatus.className = 'status warn cancelling'; UI.setFindStatus('warn cancelling', '‚õî –û—Ç–º–µ–Ω–∞...'); },

        findFromPOI: async () => {
          const activePoints = State.points.filter(p => p.enabled !== false);
          if (!State.apiLoaded || activePoints.length < 2 || State.poiResults.length === 0) return;

          State.running = true;
          State.cancelled = false;
          const runId = ++State.runId;

          const metricName = Utils.getSelectedMetric();
          const isUltra = metricName === 'ultra';
          const metricKey = isUltra ? 'composite' : metricName;
          const timeoutMs = Utils.clamp(DOM.timeout?.value, 3, 60, 15) * 1000;
          const timeContext = Utils.getSearchTime();

          const candidates = State.poiResults.map(p => p.coords);
          const origins = activePoints.map(p => p.coords);
          const transports = activePoints.map(p => p.transport || 'masstransit');
          const estimatedRoutes = candidates.length * origins.length;

          State.currentSearch = { sent: 0, ok: 0, fail: 0, expected: estimatedRoutes, cached: 0, estimated: 0, startTime: Date.now() };
          State.displayCount = 5;
          UI.showLiveStats(true);
          UI.updateLiveStats();

          if (DOM.btnFind) DOM.btnFind.disabled = true;
          if (DOM.btnCancel) DOM.btnCancel.disabled = false;
          App.clearResult();

          State.routeLimiter = Utils.createLimiter(State.settings.maxConcurrentRoutes);

          UI.setFindStatus('warn', `\ud83c\udfe2 \u041e\u0446\u0435\u043d\u043a\u0430 ${candidates.length} POI...`);
          Log.append('POI \u043e\u0446\u0435\u043d\u043a\u0430: \u0441\u0442\u0430\u0440\u0442', { poi: candidates.length, participants: origins.length });

          const progress = { count: 0, total: estimatedRoutes };
          const allResults = await Algorithm.evaluateCandidates(candidates, origins, transports, timeoutMs, runId, timeContext, progress, 'POI');

          if (runId !== State.runId) return;

          // Attach POI info to results
          allResults.forEach(r => {
            const poi = State.poiResults.find(p => p.coords[0] === r.coords[0] && p.coords[1] === r.coords[1]);
            if (poi) {
              r.poiName = poi.name;
              r.poiAddress = poi.address;
              r.poiCategory = poi.category;
            }
          });

          Algorithm.finish(allResults, metricName, isUltra, runId, 0);
        }
      };

      const App = {
        addPoint: (coords, meta = {}, silent = false) => {
          if (!State.map) return;
          if (!silent && State.results.length > 0) App.clearResult();
          if (!Utils.isValidCoord(coords)) {
            UI.setFindStatus('bad', '‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã');
            return;
          }

          const id = Utils.uuid();
          const name = meta.name || `–¢–æ—á–∫–∞ ${State.points.length + 1}`;
          const transport = meta.transport || 'masstransit';
          const color = COLORS[State.points.length % COLORS.length];

          const marker = new ymaps.Placemark(coords, {
            iconCaption: name,
            balloonContent: `<strong>${Utils.escHtml(name)}</strong><br><code>${Utils.fmtCoord(coords)}</code>`
          }, { preset: 'islands#circleIcon', iconColor: color, draggable: true });

          marker.events.add('dragend', e => {
            const newCoords = marker.geometry.getCoordinates();
            const pt = State.points.find(pp => pp.id === id);
            if (pt) {
              pt.coords = newCoords;
              marker.properties.set('balloonContent', `<strong>${Utils.escHtml(pt.name)}</strong><br><code>${Utils.fmtCoord(newCoords)}</code>`);
              if (State.results.length > 0) App.clearResult();
              UI.updatePointsList();
              App.savePoints();
              Utils.toast('üìç –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã', 'ok');
            }
          });

          State.map.geoObjects.add(marker);
          State.points.push({ id, name, coords, address: meta.address, transport, color, marker, enabled: meta.enabled !== false, returnCoords: meta.returnCoords || null, returnAddress: meta.returnAddress || '' });

          UI.updatePointsList();
          App.savePoints();

          if (!silent) Log.append('–¢–æ—á–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞', { coords, name });
        },

        removePoint: id => {
          const idx = State.points.findIndex(p => p.id === id);
          if (idx < 0) return;

          const p = State.points[idx];
          State.map.geoObjects.remove(p.marker);
          State.points.splice(idx, 1);

          UI.updatePointsList();
          App.savePoints();
        },

        renamePoint: (id, name) => {
          const p = State.points.find(p => p.id === id);
          if (!p) return;
          p.name = name || '–¢–æ—á–∫–∞';
          p.marker.properties.set('iconCaption', p.name);
          App.savePoints();
        },

        toggleTransport: id => {
          const p = State.points.find(p => p.id === id);
          if (!p) return;
          p.transport = p.transport === 'auto' ? 'masstransit' : 'auto';
          if (State.results.length > 0) App.clearResult();
          UI.updatePointsList();
          App.savePoints();
        },

        toggleEnabled: (id, enabled) => {
          const p = State.points.find(p => p.id === id);
          if (!p) return;
          p.enabled = enabled;
          if (p.marker) p.marker.options.set('opacity', enabled ? 1 : 0.3);
          if (State.results.length > 0) App.clearResult();
          UI.updatePointsList();
          App.savePoints();
        },

        setReturnPoint: async (id) => {
          const p = State.points.find(p => p.id === id);
          if (!p) return;
          const addr = prompt('–ê–¥—Ä–µ—Å –≤–æ–∑–≤—Ä–∞—Ç–∞ (–∫—É–¥–∞ –≤–µ—Ä–Ω—É—Ç—å—Å—è –ø–æ—Å–ª–µ –≤—Å—Ç—Ä–µ—á–∏):', p.returnAddress || '');
          if (addr === null) return;
          if (!addr.trim()) {
            App.clearReturnPoint(id);
            return;
          }
          if (!State.apiLoaded) { Utils.toast('API –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω', 'err'); return; }
          const result = await API.geocode(addr.trim());
          if (result.ok) {
            p.returnCoords = result.coords;
            p.returnAddress = result.address || addr.trim();
            UI.updatePointsList();
            App.savePoints();
            Utils.toast(`‚Ü©Ô∏è ${p.name}: –≤–æ–∑–≤—Ä–∞—Ç –≤ ${p.returnAddress}`, 'ok');
          } else {
            Utils.toast('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∞–¥—Ä–µ—Å', 'err');
          }
        },

        clearReturnPoint: (id) => {
          const p = State.points.find(p => p.id === id);
          if (!p) return;
          p.returnCoords = null;
          p.returnAddress = '';
          UI.updatePointsList();
          App.savePoints();
        },

        clearPoints: () => {
          State.points.forEach(p => State.map.geoObjects.remove(p.marker));
          State.points = [];
          App.clearResult();
          App.hideGridPreview();
          UI.updatePointsList();
          App.savePoints();
        },

        clearResult: () => {
          State.resultMarkers.forEach(m => { if (m) State.map.geoObjects.remove(m); });
          State.resultMarkers = [];
          State.results = [];
          State.allResults = [];
          State.ultraResults = null;
          State.displayCount = 5;
          State.heatmapData = null;
          App.hideRoutes();
          App.hideHeatmap();
          App.updateHeatmapButton();
          if (DOM.resultsContent) DOM.resultsContent.innerHTML = '<div class="empty-state">–ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø–æ–∏—Å–∫</div>';
          if (DOM.resultsBadge) DOM.resultsBadge.textContent = '‚Äî';
          if ($('ultraCompareContainer')) $('ultraCompareContainer').style.display = 'none';
          if (DOM.routesPanel) DOM.routesPanel.style.display = 'none';
          UI.showLiveStats(false);
          UI.updateFindButton();
        },

        // === POI Methods ===
        searchPOI: async () => {
          const activePoints = State.points.filter(p => p.enabled !== false);
          if (!State.apiLoaded || activePoints.length < 2) {
            Utils.toast('–í–∫–ª—é—á–∏—Ç–µ –º–∏–Ω–∏–º—É–º 2 —Ç–æ—á–∫–∏', 'err');
            return;
          }
          const query = DOM.poiQuery?.value?.trim();
          if (!query) return;

          UI.setFindStatus('warn', `üè¢ –ò—â—É "${query}"...`);
          const expandH = Utils.clamp(DOM.poiExpandH?.value, 0, 200, 30);
          const expandV = Utils.clamp(DOM.poiExpandV?.value, 0, 200, 30);
          const maxResults = Utils.clamp(DOM.poiMaxResults?.value, 5, 100, 20);
          const bbox = Math2.bbox(activePoints, expandH, expandV);
          const { places, total } = await API.searchPOI(query, bbox, maxResults);

          if (places.length === 0) {
            UI.setFindStatus('bad', `‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É "${query}"`);
            return;
          }

          App.clearPOI();
          State.poiResults = places;
          State.poiTotalFound = total;
          State.poiLastQuery = query;
          State.poiLastBbox = bbox;
          App.showPOIMarkers();
          App.renderPOIList();
          App.updatePOIInfo();
          Utils.toast(`üè¢ –ù–∞–π–¥–µ–Ω–æ ${places.length} –∏–∑ ${total} –º–µ—Å—Ç`, 'ok');
          UI.setFindStatus('ok', `‚úÖ "${query}": ${places.length} –∏–∑ ${total} –º–µ—Å—Ç`);
          if (DOM.btnEvalPOI) DOM.btnEvalPOI.disabled = false;
          if (DOM.btnClearPOI) DOM.btnClearPOI.disabled = false;
          if ($('poiBadge')) $('poiBadge').textContent = places.length;
        },

        loadMorePOI: async () => {
          if (!State.poiLastQuery || !State.poiLastBbox) return;
          const maxResults = Utils.clamp(DOM.poiMaxResults?.value, 5, 100, 20);
          const skip = State.poiResults.length;
          UI.setFindStatus('warn', `üè¢ –ó–∞–≥—Ä—É–∂–∞—é –µ—â—ë...`);
          const { places } = await API.searchPOI(State.poiLastQuery, State.poiLastBbox, maxResults, skip);
          if (places.length === 0) {
            Utils.toast('–ë–æ–ª—å—à–µ –º–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω–æ', 'info');
            UI.setFindStatus('info', `‚ÑπÔ∏è –í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–µ—Å—Ç–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã`);
            return;
          }
          State.poiResults.push(...places);
          // Add new markers
          places.forEach(poi => {
            const marker = new ymaps.Placemark(poi.coords, {
              iconCaption: poi.name,
              balloonContentHeader: `<strong>üè¢ ${Utils.escHtml(poi.name)}</strong>`,
              balloonContentBody: `<div style="font-size:11px">
                ${poi.address ? `<div>üì´ ${Utils.escHtml(poi.address)}</div>` : ''}
                <div><code>${Utils.fmtCoord(poi.coords)}</code></div>
              </div>`
            }, { preset: 'islands#orangeCircleDotIcon' });
            State.map.geoObjects.add(marker);
            State.poiMarkers.push(marker);
          });
          App.renderPOIList();
          App.updatePOIInfo();
          Utils.toast(`+${places.length} –º–µ—Å—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–æ`, 'ok');
          UI.setFindStatus('ok', `‚úÖ "${State.poiLastQuery}": ${State.poiResults.length} –∏–∑ ${State.poiTotalFound}`);
          if ($('poiBadge')) $('poiBadge').textContent = State.poiResults.length;
        },

        updatePOIInfo: () => {
          const info = $('poiFoundInfo');
          if (!info) return;
          if (State.poiResults.length === 0) {
            info.style.display = 'none';
            return;
          }
          info.style.display = 'block';
          const canLoadMore = State.poiResults.length < State.poiTotalFound;
          info.innerHTML = `üè¢ –ó–∞–≥—Ä—É–∂–µ–Ω–æ: <strong>${State.poiResults.length}</strong> –∏–∑ <strong>${State.poiTotalFound}</strong> –º–µ—Å—Ç`;
          if (DOM.btnLoadMorePOI) DOM.btnLoadMorePOI.disabled = !canLoadMore;
        },

        clearPOI: () => {
          if (State.map) State.poiMarkers.forEach(m => { try { State.map.geoObjects.remove(m); } catch { } });
          State.poiMarkers = [];
          State.poiResults = [];
          State.poiTotalFound = 0;
          State.poiLastQuery = '';
          State.poiLastBbox = null;
          const list = $('poiList');
          if (list) list.innerHTML = '';
          if ($('poiBadge')) $('poiBadge').textContent = '0';
          if ($('poiFoundInfo')) $('poiFoundInfo').style.display = 'none';
          if (DOM.btnEvalPOI) DOM.btnEvalPOI.disabled = true;
          if (DOM.btnClearPOI) DOM.btnClearPOI.disabled = true;
          if (DOM.btnLoadMorePOI) DOM.btnLoadMorePOI.disabled = true;
        },

        showPOIMarkers: () => {
          State.poiResults.forEach(poi => {
            const marker = new ymaps.Placemark(poi.coords, {
              iconCaption: poi.name,
              balloonContentHeader: `<strong>üè¢ ${Utils.escHtml(poi.name)}</strong>`,
              balloonContentBody: `<div style="font-size:11px">
                ${poi.address ? `<div>üì´ ${Utils.escHtml(poi.address)}</div>` : ''}
                <div><code>${Utils.fmtCoord(poi.coords)}</code></div>
              </div>`
            }, {
              preset: 'islands#orangeCircleDotIcon'
            });
            State.map.geoObjects.add(marker);
            State.poiMarkers.push(marker);
          });
        },

        renderPOIList: () => {
          const list = $('poiList');
          if (!list) return;
          list.innerHTML = '';
          State.poiResults.forEach(poi => {
            const item = document.createElement('div');
            item.className = 'poi-item';
            item.innerHTML = `<span class="poi-icon">üè¢</span>
              <span class="poi-name" title="${Utils.escAttr(poi.name)}">${Utils.escHtml(poi.name)}</span>
              <span class="poi-addr" title="${Utils.escAttr(poi.address)}">${Utils.escHtml(poi.address)}</span>`;
            item.addEventListener('click', () => {
              State.map.setCenter(poi.coords, 16, { duration: 300 });
            });
            list.appendChild(item);
          });
        },

        loadMore: () => {
          State.displayCount = Math.min(State.displayCount + 5, State.allResults.length);
          State.results = State.allResults.slice(0, State.displayCount);
          App.showAllResultMarkers(State.results);
          UI.showSelectedResult(State.selectedResultIndex);
        },

        // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–µ–≤—å—é —Å–µ—Ç–∫–∏ –Ω–∞ –∫–∞—Ä—Ç–µ
        showGridPreview: () => {
          App.hideGridPreview();

          if (State.points.length < 2) return;

          const gridSize = Utils.clamp(DOM.gridSize?.value, 3, 12, 6);
          const expandH = Utils.clamp(DOM.gridExpandH?.value, 0, 100, 20);
          const expandV = Utils.clamp(DOM.gridExpandV?.value, 0, 100, 20);
          const bbox = Math2.bbox(State.points, expandH, expandV);
          const candidates = Math2.generateGrid(State.points, gridSize, expandH, expandV);

          // –†–∏—Å—É–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –æ–±–ª–∞—Å—Ç–∏ –ø–æ–∏—Å–∫–∞
          const rect = new ymaps.Rectangle([
            [bbox.minLat, bbox.minLon],
            [bbox.maxLat, bbox.maxLon]
          ], {}, {
            fillColor: 'rgba(77,159,255,0.08)',
            strokeColor: '#4d9fff',
            strokeWidth: 2,
            strokeStyle: 'solid'
          });
          State.map.geoObjects.add(rect);
          State.gridPreviewObjects.push(rect);

          // –†–∏—Å—É–µ–º –ª–∏–Ω–∏–∏ —Å–µ—Ç–∫–∏
          const latStep = (bbox.maxLat - bbox.minLat) / gridSize;
          const lonStep = (bbox.maxLon - bbox.minLon) / gridSize;

          // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
          for (let i = 0; i <= gridSize; i++) {
            const lat = bbox.minLat + i * latStep;
            const line = new ymaps.Polyline([[lat, bbox.minLon], [lat, bbox.maxLon]], {}, {
              strokeColor: '#4d9fff',
              strokeWidth: 1,
              strokeOpacity: 0.4
            });
            State.map.geoObjects.add(line);
            State.gridPreviewObjects.push(line);
          }

          // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
          for (let j = 0; j <= gridSize; j++) {
            const lon = bbox.minLon + j * lonStep;
            const line = new ymaps.Polyline([[bbox.minLat, lon], [bbox.maxLat, lon]], {}, {
              strokeColor: '#4d9fff',
              strokeWidth: 1,
              strokeOpacity: 0.4
            });
            State.map.geoObjects.add(line);
            State.gridPreviewObjects.push(line);
          }

          // –†–∏—Å—É–µ–º —Ç–æ—á–∫–∏-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –≤ —Ü–µ–Ω—Ç—Ä–∞—Ö —è—á–µ–µ–∫
          candidates.forEach((c, i) => {
            const circle = new ymaps.Circle([c, 80], {}, {
              fillColor: i === 0 ? '#4d9fff' : '#6b7280',
              fillOpacity: i === 0 ? 0.8 : 0.5,
              strokeColor: i === 0 ? '#4d9fff' : '#6b7280',
              strokeWidth: 1
            });
            State.map.geoObjects.add(circle);
            State.gridPreviewObjects.push(circle);
          });

          State.showingGrid = true;
          if ($('btnShowGrid')) $('btnShowGrid').classList.add('active');

          App.fitAll();
        },

        hideGridPreview: () => {
          if (State.map) State.gridPreviewObjects.forEach(o => { try { State.map.geoObjects.remove(o); } catch { } });
          State.gridPreviewObjects = [];
          State.showingGrid = false;
          if ($('btnShowGrid')) $('btnShowGrid').classList.remove('active');
        },

        toggleGridPreview: () => {
          if (State.showingGrid) {
            App.hideGridPreview();
          } else {
            App.showGridPreview();
          }
        },

        // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ–ø–ª–æ–≤–æ–π –∫–∞—Ä—Ç—ã (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–∏—Å–∫–∞)
        saveHeatmapData: (results, metric, gridSize) => {
          if (results.length < 2) {
            State.heatmapData = null;
            return;
          }

          const scores = results.map(r => r.scores[metric]);
          const minScore = Math.min(...scores);
          const maxScore = Math.max(...scores);

          // –í—ã—á–∏—Å–ª—è–µ–º bbox –∏ —Ä–∞–∑–º–µ—Ä—ã —è—á–µ–µ–∫
          const lats = results.map(r => r.coords[0]);
          const lons = results.map(r => r.coords[1]);
          const minLat = Math.min(...lats);
          const maxLat = Math.max(...lats);
          const minLon = Math.min(...lons);
          const maxLon = Math.max(...lons);

          // –†–∞–∑–º–µ—Ä —è—á–µ–π–∫–∏ (–ø–æ–ª–æ–≤–∏–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É —Ç–æ—á–∫–∞–º–∏)
          const latStep = (maxLat - minLat) / (gridSize - 1) || 0.005;
          const lonStep = (maxLon - minLon) / (gridSize - 1) || 0.007;
          const halfLatStep = latStep / 2;
          const halfLonStep = lonStep / 2;

          State.heatmapData = {
            results,
            metric,
            minScore,
            maxScore,
            halfLatStep,
            halfLonStep
          };

          // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É
          App.updateHeatmapButton();
        },

        updateHeatmapButton: () => {
          const btn = $('btnToggleHeatmap');
          if (!btn) return;

          const hasData = State.heatmapData !== null;
          btn.disabled = !hasData;
          btn.classList.toggle('active', State.showingHeatmap);
          btn.title = hasData
            ? (State.showingHeatmap ? '–°–∫—Ä—ã—Ç—å —Ç–µ–ø–ª–æ–≤—É—é –∫–∞—Ä—Ç—É' : '–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–ø–ª–æ–≤—É—é –∫–∞—Ä—Ç—É')
            : '–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–∏—Å–∫';
        },

        toggleHeatmap: () => {
          if (!State.heatmapData) return;

          if (State.showingHeatmap) {
            App.hideHeatmap();
          } else {
            App.showHeatmap();
          }
        },

        // –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–ø–ª–æ–≤—É—é –∫–∞—Ä—Ç—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–∫–≤–∞–¥—Ä–∞—Ç–∞–º–∏)
        showHeatmap: () => {
          App.hideHeatmap();

          const data = State.heatmapData;
          if (!data || data.results.length < 2) return;

          const { results, metric, minScore, maxScore, halfLatStep, halfLonStep } = data;

          results.forEach((r, idx) => {
            const color = Utils.scoreToColor(r.scores[metric], minScore, maxScore);
            const [lat, lon] = r.coords;

            // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ balloon
            const timesHtml = r.routes.map(route =>
              `<div style="display:flex;justify-content:space-between;margin:2px 0;">
              <span style="color:${route.color};">‚óè</span> ${Utils.escHtml(route.name)}: 
              <strong>${Utils.secToStr(route.duration)}</strong>
            </div>`
            ).join('');

            const rank = results.indexOf(r) + 1;
            const scoreNorm = ((r.scores[metric] - minScore) / (maxScore - minScore || 1) * 100).toFixed(0);

            // –°–æ–∑–¥–∞—ë–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ (–∫–≤–∞–¥—Ä–∞—Ç) –¥–ª—è —è—á–µ–π–∫–∏
            const rect = new ymaps.Rectangle([
              [lat - halfLatStep, lon - halfLonStep],
              [lat + halfLatStep, lon + halfLonStep]
            ], {
              balloonContentHeader: `<strong>üìä –Ø—á–µ–π–∫–∞ #${idx + 1}</strong>`,
              balloonContentBody: `
              <div style="font-size:11px;">
                <div style="margin-bottom:6px;">
                  <code style="font-size:9px;">${Utils.fmtCoord(r.coords)}</code>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-bottom:8px;">
                  <div><span style="color:var(--muted);">–°—Ä–µ–¥–Ω–µ–µ:</span> <strong>${Utils.secToStr(r.mean)}</strong></div>
                  <div><span style="color:var(--muted);">–ú–∞–∫—Å:</span> <strong>${Utils.secToStr(r.max)}</strong></div>
                  <div><span style="color:var(--muted);">–†–∞–∑–Ω–∏—Ü–∞:</span> <strong>${Utils.secToStr(r.range)}</strong></div>
                  <div><span style="color:var(--muted);">Score:</span> <strong>${scoreNorm}%</strong></div>
                </div>
                <div style="border-top:1px solid #ddd;padding-top:6px;">
                  ${timesHtml}
                </div>
              </div>
            `,
              hintContent: `–°—Ä–µ–¥–Ω–µ–µ: ${Utils.secToStr(r.mean)}, –º–∞–∫—Å: ${Utils.secToStr(r.max)}`
            }, {
              fillColor: color,
              strokeColor: color.replace('0.5)', '0.9)'),
              strokeWidth: 1,
              fillOpacity: 0.6
            });

            State.map.geoObjects.add(rect);
            State.heatmapObjects.push(rect);
          });

          State.showingHeatmap = true;
          App.updateHeatmapButton();
        },

        hideHeatmap: () => {
          if (State.map) State.heatmapObjects.forEach(o => { try { State.map.geoObjects.remove(o); } catch { } });
          State.heatmapObjects = [];
          State.showingHeatmap = false;
          App.updateHeatmapButton();
        },

        showAllResultMarkers: results => {
          State.resultMarkers.forEach(m => { if (m) State.map.geoObjects.remove(m); });
          State.resultMarkers = [];

          results.forEach((result, i) => {
            const timesText = result.routes.map(r => {
              const walkExtra = r.walkAfterTransport > 60 ? ` (+${Utils.secToStrShort(r.walkAfterTransport)} üö∂)` : '';
              return `${r.name}: ${Utils.secToStr(r.duration)}${walkExtra}`;
            }).join('<br>');
            const walkNote = result.maxWalk < 180 ? '<br><em style="color:#34d399;">üöá –†—è–¥–æ–º —Å —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–æ–º</em>' : '';

            const marker = new ymaps.Placemark(result.coords, {
              iconCaption: result.poiName ? `#${i + 1} ${result.poiName}` : `#${i + 1}`,
              balloonContentHeader: result.poiName
                ? `<strong>‚≠ê #${i + 1} üè¢ ${Utils.escHtml(result.poiName)}</strong>`
                : `<strong>‚≠ê #${i + 1} –¢–æ—á–∫–∞ –≤—Å—Ç—Ä–µ—á–∏</strong>`,
              balloonContentBody: `
              ${result.poiAddress ? `<div style="font-size:11px;color:#888;margin-bottom:4px">üì´ ${Utils.escHtml(result.poiAddress)}</div>` : ''}
              <div style="font-size:12px;margin-bottom:8px;">
                <strong>–°—Ä–µ–¥–Ω–µ–µ:</strong> ${Utils.secToStr(result.mean)}<br>
                <strong>–†–∞–∑–Ω–∏—Ü–∞:</strong> ${Utils.secToStr(result.range)}
                ${walkNote}
              </div>
              <div style="font-size:11px;border-top:1px solid #ddd;padding-top:6px;">
                ${timesText}
              </div>
            `,
              balloonContentFooter: `<code style="font-size:10px;">${Utils.fmtCoord(result.coords)}</code>`
            }, {
              preset: i === 0 ? 'islands#redStarIcon' : 'islands#grayCircleDotIcon',
              iconColor: RESULT_COLORS[Math.min(i, RESULT_COLORS.length - 1)]
            });

            marker.events.add('click', () => {
              App.selectResult(i);
            });

            State.map.geoObjects.add(marker);
            State.resultMarkers.push(marker);
          });

          App.fitAll();
        },

        selectResult: index => {
          if (index < 0 || index >= State.results.length) return;

          App.hideRoutes();
          UI.showSelectedResult(index);
          App.showRoutesOnMap(index);
        },

        showRoutesOnMap: async (index) => {
          if (State.results.length === 0) return;
          const result = State.results[index];

          App.hideRoutes();

          for (const p of State.points) {
            const mr = new ymaps.multiRouter.MultiRoute({
              referencePoints: [p.coords, result.coords],
              params: { routingMode: p.transport === 'auto' ? 'auto' : 'masstransit' }
            }, { boundsAutoApply: false, routeActiveStrokeColor: p.color, routeActiveStrokeWidth: 4 });

            State.map.geoObjects.add(mr);
            State.routeObjects.push(mr);
            await new Promise(r => setTimeout(r, 80));
          }
        },

        fitAll: () => {
          if (!State.map || State.points.length === 0) return;
          const coords = State.points.map(p => p.coords);
          State.results.forEach(r => coords.push(r.coords));
          State.gridPreviewObjects.forEach(o => {
            if (o.geometry?.getCoordinates) {
              const c = o.geometry.getCoordinates();
              if (Array.isArray(c) && c.length === 2 && typeof c[0] === 'number') coords.push(c);
            }
          });
          if (coords.length > 0) {
            State.map.setBounds(ymaps.util.bounds.fromPoints(coords), { checkZoomRange: true, zoomMargin: 60 });
          }
        },

        savePoints: () => {
          try {
            const data = State.points.map(p => ({ name: p.name, coords: p.coords, address: p.address, transport: p.transport, enabled: p.enabled !== false, returnCoords: p.returnCoords || null, returnAddress: p.returnAddress || '' }));
            localStorage.setItem('fmp_points', JSON.stringify(data));
          } catch { }
        },

        hideRoutes: () => {
          if (State.map) State.routeObjects.forEach(r => { try { State.map.geoObjects.remove(r); } catch { } });
          State.routeObjects = [];
        },

        copyCoords: async (coords) => {
          const ok = await Utils.copyToClipboard(coords);
          if (ok) Utils.toast('üìã –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã!', 'ok');
        },

        getMyLocation: () => {
          if (!navigator.geolocation) { alert('–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞'); return; }
          UI.setFindStatus('warn', 'üìç –û–ø—Ä–µ–¥–µ–ª—è—é –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ...');

          navigator.geolocation.getCurrentPosition(
            pos => {
              const coords = [pos.coords.latitude, pos.coords.longitude];
              const name = DOM.inputName?.value.trim() || '–ú–æ—ë –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ';
              const transport = DOM.inputTransport?.value || 'masstransit';
              App.addPoint(coords, { name, transport });
              if (DOM.inputName) DOM.inputName.value = '';
              State.map.setCenter(coords, 14, { duration: 300 });
              UI.setFindStatus('ok', '‚úÖ –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∞');
            },
            err => UI.setFindStatus('bad', '‚ùå ' + err.message),
            { enableHighAccuracy: true, timeout: 10000 }
          );
        },

        adjustTime: deltaMinutes => {
          if (!DOM.departureTime) return;
          const current = DOM.departureTime.value ? new Date(DOM.departureTime.value) : new Date();
          current.setMinutes(current.getMinutes() + deltaMinutes);
          DOM.departureTime.value = Utils.toLocalISOString(current);
        },

        setNow: () => {
          if (!DOM.departureTime) return;
          DOM.departureTime.value = Utils.toLocalISOString(new Date());
        },

        exportStats: () => {
          const data = { stats: State.stats, history: State.history, exportedAt: new Date().toISOString() };
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const a = document.createElement('a');
          const url = URL.createObjectURL(blob);
          a.href = url;
          a.download = `fmp_stats_${new Date().toISOString().slice(0, 10)}.json`;
          a.click();
          URL.revokeObjectURL(url);
        },

        resetStats: () => {
          State.stats = { geocode: { total: 0, ok: 0, fail: 0 }, route: { total: 0, ok: 0, fail: 0, timeout: 0 } };
          UI.updateStats();
        },

        init: () => {
          const ids = ['apiKey', 'btnLoadApi', 'btnToggleKey', 'apiStatus', 'apiBadge', 'inputAddr', 'inputName', 'inputTransport', 'btnAddPoint', 'btnMyLocation', 'pointsList', 'pointsBadge', 'btnClearPoints', 'btnFitAll', 'gridSize', 'gridExpandH', 'gridExpandV', 'timeout', 'departureTime', 'btnNow', 'btnTimeUp', 'btnTimeDown', 'btnTimeDeparture', 'btnTimeArrival', 'btnFind', 'btnCancel', 'findStatus', 'progressContainer', 'progressFill', 'progressPhase', 'progressPct', 'estRequests', 'estCost', 'resultsContent', 'resultsBadge', 'routesPanel', 'chipTotal', 'chipOk', 'chipFail', 'btnResetStats', 'btnExportStats', 'logArea', 'btnClearLog', 'btnCopyLog', 'themeBtn', 'btnHelp', 'btnShowGrid', 'btnToggleHeatmap', 'poiQuery', 'btnSearchPOI', 'btnEvalPOI', 'btnClearPOI', 'poiBadge', 'poiExpandH', 'poiExpandV', 'poiMaxResults', 'btnLoadMorePOI', 'chkReturnTrip'];
          ids.forEach(id => DOM[id] = $(id));

          try { const theme = localStorage.getItem('fmp_theme'); if (theme) UI.setTheme(theme); } catch { }
          try { const stats = localStorage.getItem('fmp_stats'); if (stats) State.stats = JSON.parse(stats); UI.updateStats(); } catch { }
          try { const key = localStorage.getItem('fmp_apikey'); if (key && DOM.apiKey) DOM.apiKey.value = key; } catch { }
          try { Cache.load(); } catch { }
          State.routeLimiter = Utils.createLimiter(State.settings.maxConcurrentRoutes);

          if (DOM.departureTime) {
            const now = new Date();
            now.setHours(now.getHours() + 1);
            now.setMinutes(Math.round(now.getMinutes() / 15) * 15);
            DOM.departureTime.value = Utils.toLocalISOString(now);

            DOM.departureTime.addEventListener('wheel', function (e) {
              e.preventDefault();
              e.stopPropagation();
              const delta = e.deltaY < 0 ? 15 : -15;
              App.adjustTime(delta);
              return false;
            }, { passive: false });
          }

          if (DOM.themeBtn) DOM.themeBtn.addEventListener('click', UI.toggleTheme);
          if (DOM.btnHelp) DOM.btnHelp.addEventListener('click', () => UI.openModal('modalHelp'));
          if (DOM.btnToggleKey) DOM.btnToggleKey.addEventListener('click', () => { if (DOM.apiKey) DOM.apiKey.type = DOM.apiKey.type === 'password' ? 'text' : 'password'; });
          if (DOM.btnLoadApi) DOM.btnLoadApi.addEventListener('click', () => API.loadYandex(DOM.apiKey?.value));

          if (DOM.btnTimeDeparture) DOM.btnTimeDeparture.addEventListener('click', () => UI.setTimeMode('departure'));
          if (DOM.btnTimeArrival) DOM.btnTimeArrival.addEventListener('click', () => UI.setTimeMode('arrival'));

          if (DOM.btnTimeUp) DOM.btnTimeUp.addEventListener('click', () => App.adjustTime(15));
          if (DOM.btnTimeDown) DOM.btnTimeDown.addEventListener('click', () => App.adjustTime(-15));
          if (DOM.btnNow) DOM.btnNow.addEventListener('click', App.setNow);

          if ($('btnShowGrid')) $('btnShowGrid').addEventListener('click', App.toggleGridPreview);
          if ($('btnToggleHeatmap')) $('btnToggleHeatmap').addEventListener('click', App.toggleHeatmap);

          if (DOM.btnAddPoint) DOM.btnAddPoint.addEventListener('click', async () => {
            const addr = DOM.inputAddr?.value.trim();
            if (!addr) return;

            if (State.results.length > 0) {
              const ok = await Utils.customConfirm('‚ö†Ô∏è –°–±—Ä–æ—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤', '–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Ç–æ—á–∫–∏ —Å–±—Ä–æ—Å–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?');
              if (!ok) return;
            }

            // Try to parse as coordinates first
            const parsed = Utils.parseCoords(addr);
            if (parsed) {
              const name = DOM.inputName?.value.trim() || `–¢–æ—á–∫–∞ ${State.points.length + 1}`;
              const transport = DOM.inputTransport?.value || 'masstransit';
              App.addPoint(parsed, { name, transport });
              if (DOM.inputAddr) DOM.inputAddr.value = '';
              if (DOM.inputName) DOM.inputName.value = '';
              State.map.setCenter(parsed, 14, { duration: 300 });
              Utils.toast('üìç –¢–æ—á–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º', 'ok');
              return;
            }

            const result = await API.geocode(addr);
            if (result.ok) {
              const name = DOM.inputName?.value.trim() || `–¢–æ—á–∫–∞ ${State.points.length + 1}`;
              const transport = DOM.inputTransport?.value || 'masstransit';
              App.addPoint(result.coords, { name, address: result.address, transport });
              if (DOM.inputAddr) DOM.inputAddr.value = '';
              if (DOM.inputName) DOM.inputName.value = '';
              State.map.setCenter(result.coords, 14, { duration: 300 });
            } else {
              UI.setFindStatus('bad', '‚ùå ' + result.error);
            }
          });

          if (DOM.inputAddr) DOM.inputAddr.addEventListener('keydown', e => { if (e.key === 'Enter' && DOM.btnAddPoint) DOM.btnAddPoint.click(); });
          if (DOM.apiKey) DOM.apiKey.addEventListener('keydown', e => { if (e.key === 'Enter' && DOM.btnLoadApi) DOM.btnLoadApi.click(); });
          if (DOM.btnMyLocation) DOM.btnMyLocation.addEventListener('click', App.getMyLocation);
          if (DOM.btnClearPoints) DOM.btnClearPoints.addEventListener('click', async () => {
            const ok = await Utils.customConfirm('üóëÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–æ—á–∫–∏?');
            if (ok) App.clearPoints();
          });
          if (DOM.btnFitAll) DOM.btnFitAll.addEventListener('click', App.fitAll);

          // Composite metric weight sliders
          const updateWeightsVisibility = () => {
            const cw = $('compositeWeights');
            if (cw) {
              const v = Utils.getSelectedMetric();
              cw.classList.toggle('show', v === 'composite' || v === 'nearmetro' || v === 'ultra');
            }
          };
          document.querySelectorAll('input[name="metric"]').forEach(radio => {
            radio.addEventListener('change', () => { UI.updateEstimates(); updateWeightsVisibility(); });
          });
          updateWeightsVisibility();
          ['weightAlpha', 'weightBeta', 'weightGamma'].forEach(id => {
            const el = $(id);
            if (el) el.addEventListener('input', () => {
              State.compositeWeights.alpha = $("weightAlpha").value / 10;
              State.compositeWeights.beta = $("weightBeta").value / 10;
              State.compositeWeights.gamma = $("weightGamma").value / 10;
              $("weightAlphaVal").textContent = State.compositeWeights.alpha.toFixed(1);
              $("weightBetaVal").textContent = State.compositeWeights.beta.toFixed(1);
              $("weightGammaVal").textContent = State.compositeWeights.gamma.toFixed(1);
            });
          });

          // Debounce grid parameter changes
          const debouncedUpdate = Utils.debounce(UI.updateEstimates, CONSTANTS.DEBOUNCE_MS);
          if (DOM.gridSize) DOM.gridSize.addEventListener('input', debouncedUpdate);
          if (DOM.gridExpandH) DOM.gridExpandH.addEventListener('input', debouncedUpdate);
          if (DOM.gridExpandV) DOM.gridExpandV.addEventListener('input', debouncedUpdate);

          if (DOM.btnFind) DOM.btnFind.addEventListener('click', Algorithm.find);
          if (DOM.btnCancel) DOM.btnCancel.addEventListener('click', Algorithm.cancel);
          if (DOM.chkReturnTrip) DOM.chkReturnTrip.addEventListener('change', () => { State.returnTrip = DOM.chkReturnTrip.checked; UI.updateEstimates(); });

          // POI event listeners
          if (DOM.btnSearchPOI) DOM.btnSearchPOI.addEventListener('click', App.searchPOI);
          if (DOM.poiQuery) DOM.poiQuery.addEventListener('keydown', e => { if (e.key === 'Enter' && DOM.btnSearchPOI) DOM.btnSearchPOI.click(); });
          if (DOM.btnEvalPOI) DOM.btnEvalPOI.addEventListener('click', Algorithm.findFromPOI);
          if (DOM.btnLoadMorePOI) DOM.btnLoadMorePOI.addEventListener('click', App.loadMorePOI);
          if (DOM.btnClearPOI) DOM.btnClearPOI.addEventListener('click', App.clearPOI);

          if (DOM.btnResetStats) DOM.btnResetStats.addEventListener('click', App.resetStats);
          if (DOM.btnExportStats) DOM.btnExportStats.addEventListener('click', App.exportStats);

          if (DOM.btnClearLog) DOM.btnClearLog.addEventListener('click', Log.clear);
          if (DOM.btnCopyLog) DOM.btnCopyLog.addEventListener('click', async () => {
            try { await navigator.clipboard.writeText(DOM.logArea?.value || ''); Utils.toast('üìã –õ–æ–≥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω', 'ok'); } catch { }
          });

          // Keyboard shortcuts
          document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
              const open = document.querySelector('.modal-overlay.show');
              if (open) open.classList.remove('show');
            }
          });

          document.querySelectorAll('.modal-overlay').forEach(m => {
            m.addEventListener('click', e => { if (e.target === m) m.classList.remove('show'); });
          });

          Log.append('–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ v3.0');

          if (DOM.apiKey?.value) setTimeout(() => API.loadYandex(DOM.apiKey.value), 300);
        }
      };

      window.App = App;
      window.UI = UI;
      App.init();
    })();
  </script>
</body>

</html>